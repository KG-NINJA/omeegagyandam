<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Gyandam Lock-On Frame</title>
  <style>
    html,
    body {
      margin: 0;
      background: #000;
      color: #0ff;
      font-family: "Courier New", monospace;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      color: #0ff;
    }

    #hud {
      position: absolute;
      bottom: 12px;
      left: 12px;
      font-size: 14px;
      line-height: 1.4;
      white-space: pre;
    }

    #comms {
      position: absolute;
      top: 12px;
      left: 12px;
      font-size: 12px;
      line-height: 1.4;
      max-width: 360px;
      color: #8ff;
      text-shadow: 0 0 6px #0bf;
      white-space: pre-line;
    }

    #message {
      position: absolute;
      top: 36%;
      width: 100%;
      text-align: center;
      font-size: 32px;
      letter-spacing: 4px;
    }

    #aiPanel {
      position: fixed;
      top: 8px;
      left: 8px;
      width: 150px;
      height: 100px;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      z-index: 1000;
      pointer-events: none;
    }

    #aiPanelGuide {
      position: fixed;
      top: 120px;
      left: 12px;
      max-width: 260px;
      padding: 4px 6px;
      font-size: 11px;
      line-height: 1.4;
      font-family: "Roboto Mono", "SFMono-Regular", "Menlo", monospace;
      color: #e9f5ff;
      background: rgba(0, 0, 0, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.5);
      border-radius: 4px;
      letter-spacing: 0.04em;
      pointer-events: none;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
  </style>
</head>

<body>
  <canvas id="screen"></canvas>
  <div id="overlay">
    <div id="comms"></div>
    <div id="hud"></div>
    <div id="message"></div>
  </div>
  <canvas id="aiPanel" width="150" height="100" aria-hidden="true"></canvas>
  <div id="aiPanelGuide" aria-hidden="true">VISION AI KEY: H = SHIELD / E = NEAREST ENEMY + DIST / S = PHASE CODE / EV =
    EVENT CODE</div>
  <script>
    (() => {
      const canvas = document.getElementById("screen");
      const ctx = canvas.getContext("2d");
      const hud = document.getElementById("hud");
      const message = document.getElementById("message");
      const comms = document.getElementById("comms");
      const aiPanelCanvas = document.getElementById("aiPanel");
      const aiPanelCtx = aiPanelCanvas ? aiPanelCanvas.getContext("2d", { alpha: false }) : null;
      const aiPanelGuide = document.getElementById("aiPanelGuide");
      if (aiPanelCtx) {
        aiPanelCtx.imageSmoothingEnabled = false;
      }
      const state = {
        running: true,
        enemies: [],
        lasers: [],
        explosions: [],
        shockwaves: [],
        chainReactions: [],
        stars: [],
        inputs: {},
        speed: 50,
        shield: 100,
        score: 0,
        roll: 0,
        yaw: 0,
        pitch: 0,
        lastTime: 0,
        timeSinceStart: 0,
        zoneSpawnIndex: 0,
        enemyShots: [],
        debugMode: false,
        loopCount: 0,
        messageTimer: 0,
        formations: {},
        navLog: [],
        chatterTimer: 0,
        nextChatter: 6,
        warpPhase: "entry",
        warpTimer: 0,
        warpIntensity: 0,
        warpRingTimer: 0,
        warpFlashIntensity: 0,
        sectorLabel: "GYANDAM FRAME / LOCKON FIELD",
        warpAnnounceDone: false,
        lockedTargets: [],
        powerMeter: 0,
        comboCount: 0,
        comboTimer: 0,
        superModeActive: false,
        superModeTimer: 0,
        superReady: false,
        superHinted: false,
        superFireTimer: 0,
        superShotsRemaining: 0,
        lockPulse: 0,
        lockingAnchor: null,
        homingChainCount: 0,
        homingChainTimer: 0,
        homingOverheat: 0,
        // スーパーモード派手演出用
        superFlashIntensity: 0,
        superPsychicWaves: [],
        newtypeAuraParticles: [],
        superHueShift: 0,
        // 起承転結の「転」を成立させるための乱入フラグ（旗艦戦でライバル機を出す）
        rivalSpawned: false,
        rivalDefeated: false
      };
      const settings = {
        starCount: 120,
        fov: 400,
        enemyRetreatBase: 32,
        formationRetreatBase: 30,
        maxApproachRate: 34,
        enemyRecedeFactor: 0.45,
        maxShield: 100,
        minSpeed: 20,
        maxSpeed: 120,
        agilityBase: 60,
        agilityQuick: 110,
        rollReturn: 4,
        rollYawInfluence: 0.5,
        rollVisualFactor: 0.02
      };
      const lockSettings = {
        radius: 46,
        holdTime: 0.05, // レティクル捕捉と同時にロックするため極小値
        decayRate: 1.3,
        maxTargets: 5,
        volleyDelayStep: 0.08,
        minDepth: 2 // 至近距離でもロックできるよう最小距離閾値を緩和
      };
      const powerSettings = {
        comboWindow: 3,
        killBase: 6,
        comboBonus: 1,
        hitBase: 3,
        maxPower: 220,
        superDuration: 8,
        superComboMin: 4,
        superMinIntensity: 0.25
      };
      const superSettings = {
        worldTimeScale: 0.32,
        autoFireInterval: 0.18,
        autoLockMax: 12,
        autoShotLimit: 15
      };
      const homingWeaponSettings = {
        maxChain: 5,
        chainWindow: 2.2,
        overheatCooldown: 3.5
      };
      const stageConfig = {
        battleships: 1,
        escortsPerShip: 1,
        fighterWaves: 2,
        fightersPerWave: 4,
        dreadnoughtEscorts: 4
      };
      const enemyFireSettings = {
        minDelay: 4.6,
        maxDelay: 8.2,
        blindCone: 52,
        verticalCone: 22,
        behindThreshold: 18,
        fireChance: 0.12
      };
      const enemyFireRamp = {
        // ステージ序盤は緩く、終盤ほど攻撃密度を上げる
        minDelayEasy: 6.2,
        maxDelayEasy: 10.8,
        minDelayHard: 2.6,
        maxDelayHard: 5.4,
        fireChanceEasy: 0.07,
        fireChanceHard: 0.22,
        blindConeEasy: 44,
        blindConeHard: 72,
        verticalConeEasy: 18,
        verticalConeHard: 32,
        behindThresholdEasy: 24,
        behindThresholdHard: 12,
        rocketSpeedEasy: 6.2,
        rocketSpeedHard: 10.8,
        rocketAccelEasy: 16,
        rocketAccelHard: 28
      };
      const explosionSettings = {
        extraDelay: 0.35
      };
      const stageZones = [
        // 起承転結の構成をデータで固定し、山場のメリハリを作る
        {
          act: "起",
          label: "宙域侵入",
          baseZ: 300,
          startDelay: 8,
          intensity: 0.05,
          fighterWaves: 1,
          fightersPerWave: 6,
          waveInterval: 11,
          message: "起: 先遣隊を掃討せよ",
          comms: [
            "管制: 敵宙域へ侵入、迎撃が来るぞ",
            "副砲塔: ロックオン優先、初手で数を減らせ"
          ]
        },
        {
          act: "起",
          label: "先遣迎撃",
          baseZ: 280,
          startDelay: 16,
          intensity: 0.18,
          fighterWaves: 2,
          fightersPerWave: 7,
          waveInterval: 12,
          message: "起: 迎撃編隊、数で押してくる",
          comms: [
            "索敵: 小型機増加、連続撃破で押し返せ",
            "副砲塔: ロックを外すな、中央に集めろ"
          ]
        },
        {
          act: "承",
          label: "護衛艦隊",
          baseZ: 250,
          startDelay: 28,
          intensity: 0.35,
          fighterWaves: 2,
          fightersPerWave: 8,
          corvettes: 2,
          waveInterval: 13,
          message: "承: 護衛艦を突破せよ",
          comms: [
            "索敵: 護衛艦複数、隊列を組んで接近",
            "管制: 無理に突っ込むな、ロックで崩せ"
          ]
        },
        {
          act: "承",
          label: "砲撃回廊",
          baseZ: 225,
          startDelay: 44,
          intensity: 0.52,
          fighterWaves: 2,
          fightersPerWave: 9,
          corvettes: 3,
          battleships: true,
          battleshipCount: 1,
          escortsPerShip: 2,
          fleetEscortRing: 1,
          fleetEscortRadius: 16,
          fleetEscortOffsetZ: 4,
          waveInterval: 12,
          battleSpacing: 24,
          message: "承: 砲撃回廊、回避しながら崩せ",
          comms: [
            "管制: 砲撃が濃い、速度を落とすな！",
            "僚機: 直線に乗るな、ロールで抜けろ"
          ]
        },
        {
          act: "転",
          label: "反転奇襲",
          baseZ: 205,
          startDelay: 60,
          intensity: 0.7,
          fighterWaves: 2,
          fightersPerWave: 10,
          corvettes: 3,
          battleships: true,
          battleshipCount: 2,
          escortsPerShip: 2,
          fleetEscortRing: 2,
          fleetEscortRadius: 16,
          fleetEscortOffsetZ: 4,
          waveInterval: 12,
          battleSpacing: 22,
          message: "転: ジャミング発生、奇襲艦隊だ",
          comms: [
            "管制: 通信にノイズ…敵が反転してきた！",
            "???: ……ここから先は通さない（未識別信号）"
          ]
        },
        {
          act: "結",
          label: "旗艦決戦",
          baseZ: 150,
          startDelay: 80,
          intensity: 0.9,
          fighterWaves: 1,
          fightersPerWave: 8,
          corvettes: 2,
          dreadnought: true,
          dreadnoughtEscorts: 4,
          waveInterval: 14,
          message: "結: 旗艦コアを破壊せよ",
          comms: [
            "管制: 旗艦接近！三点ロックで装甲を剥がせ！",
            "ロボ砲塔: ブリッジを落としてコアを露出させろ"
          ]
        }
      ];
      let aiPanelTimer = null;

      function clamp01(value) {
        return Math.max(0, Math.min(1, value));
      }

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

      function getActiveZoneIndex() {
        const raw = (state.zoneSpawnIndex || 0) - 1;
        return Math.max(0, Math.min(stageZones.length - 1, raw));
      }

      function getStageIntensity() {
        if (!stageZones.length) return 0;
        if (state.warpPhase !== "combat") return 0;
        const idx = getActiveZoneIndex();
        const zone = stageZones[idx] || stageZones[0];
        const base = Number.isFinite(zone.intensity) ? zone.intensity : idx / Math.max(1, stageZones.length - 1);
        const nextZone = stageZones[Math.min(stageZones.length - 1, idx + 1)];
        const nextBase = Number.isFinite(nextZone?.intensity)
          ? nextZone.intensity
          : Math.min(1, (idx + 1) / Math.max(1, stageZones.length - 1));
        const rampWindow = zone.intensityRamp ?? 14;
        const t = clamp01((state.timeSinceStart - (zone.startDelay || 0)) / Math.max(1, rampWindow));
        return lerp(base, nextBase, t);
      }

      function getEnemyFireProfile() {
        const t = clamp01(getStageIntensity());
        return {
          intensity: t,
          minDelay: lerp(enemyFireRamp.minDelayEasy, enemyFireRamp.minDelayHard, t),
          maxDelay: lerp(enemyFireRamp.maxDelayEasy, enemyFireRamp.maxDelayHard, t),
          fireChance: lerp(enemyFireRamp.fireChanceEasy, enemyFireRamp.fireChanceHard, t),
          blindCone: lerp(enemyFireRamp.blindConeEasy, enemyFireRamp.blindConeHard, t),
          verticalCone: lerp(enemyFireRamp.verticalConeEasy, enemyFireRamp.verticalConeHard, t),
          behindThreshold: lerp(enemyFireRamp.behindThresholdEasy, enemyFireRamp.behindThresholdHard, t),
          rocketSpeed: lerp(enemyFireRamp.rocketSpeedEasy, enemyFireRamp.rocketSpeedHard, t),
          rocketAccel: lerp(enemyFireRamp.rocketAccelEasy, enemyFireRamp.rocketAccelHard, t)
        };
      }

      function getPowerPercent() {
        if (!powerSettings.maxPower) return 0;
        return Math.max(0, Math.min(100, Math.round((state.powerMeter / powerSettings.maxPower) * 100)));
      }

      function canReadySuper() {
        const intensityOk = getStageIntensity() >= (powerSettings.superMinIntensity ?? 0);
        const comboOk = (state.comboCount || 0) >= (powerSettings.superComboMin ?? 0);
        return intensityOk && comboOk;
      }

      // === Vision-AI用パネル描画・テレメトリ ===
      function renderAIPanel(snapshot) {
        if (!aiPanelCtx || !aiPanelCanvas || !snapshot) return;
        const width = aiPanelCanvas.width;
        const height = aiPanelCanvas.height;
        aiPanelCtx.save();
        aiPanelCtx.fillStyle = "#000";
        aiPanelCtx.fillRect(0, 0, width, height);
        aiPanelCtx.fillStyle = "#fff";
        aiPanelCtx.font = "12px \"Roboto Mono\", \"SFMono-Regular\", \"Menlo\", monospace";
        aiPanelCtx.textBaseline = "top";
        aiPanelCtx.textAlign = "left";
        const lines = [
          `H${snapshot.hp}`,
          `E${snapshot.enemyId}/${snapshot.enemyDist}`,
          `S${snapshot.stage}`,
          `EV${snapshot.event}`
        ];
        for (let i = 0; i < lines.length; i++) {
          aiPanelCtx.fillText(lines[i], 8, 8 + i * 20);
        }
        aiPanelCtx.restore();
      }

      function getNearestEnemySnapshot() {
        let bestDist = Number.POSITIVE_INFINITY;
        let bestId = "NONE";
        for (const enemy of state.enemies) {
          if (!enemy || enemy.retired) continue;
          const dist = Math.abs(enemy.z ?? Number.POSITIVE_INFINITY);
          if (!Number.isFinite(dist)) continue;
          if (dist < bestDist) {
            bestDist = dist;
            const rawId = enemy.code || enemy.type || enemy.className || "UNK";
            bestId = rawId.toString().toUpperCase().slice(0, 6);
          }
        }
        if (!Number.isFinite(bestDist)) {
          bestDist = 0;
          bestId = "NONE";
        }
        return {
          enemyId: bestId,
          enemyDist: Math.max(0, Math.round(bestDist))
        };
      }

      function deriveStageCode() {
        if (state.warpPhase !== "combat") return "WP";
        if (state.enemies.some(e => e.type === "rival" && !e.pendingExplosion && !e.retired)) return "RV";
        if (state.enemies.some(e => e.type === "dreadnought" && !e.pendingExplosion && !e.retired)) return "FG";
        if (state.enemies.some(e => e.type === "battleship" && !e.pendingExplosion && !e.retired)) return "BS";
        if (state.enemies.some(e => e.type === "corvette" && !e.pendingExplosion && !e.retired)) return "CV";
        return "DF";
      }

      function deriveEventCode() {
        if (!state.running && !state.debugMode) return 99;
        if (state.warpPhase !== "combat") return 20;
        if (state.enemies.some(e => e.type === "rival" && !e.pendingExplosion && !e.retired)) return 90;
        if (state.enemies.some(e => e.type === "dreadnought" && !e.pendingExplosion && !e.retired)) return 80;
        if (state.enemies.some(e => e.type === "battleship" && !e.pendingExplosion && !e.retired)) return 70;
        if (state.shield <= 25 && !state.debugMode) return 40;
        return 10;
      }

      function collectAIPanelState() {
        const nearest = getNearestEnemySnapshot();
        return {
          hp: Math.max(0, Math.round(state.shield ?? 0)),
          enemyId: nearest.enemyId,
          enemyDist: nearest.enemyDist,
          stage: deriveStageCode(),
          event: deriveEventCode()
        };
      }

      function initAIPanelLoop() {
        if (!aiPanelCanvas || !aiPanelCtx || aiPanelTimer) return;
        aiPanelTimer = setInterval(() => {
          renderAIPanel(collectAIPanelState());
        }, 300);
      }

      function updateAIPanelGuideVisibility() {
        if (!aiPanelGuide) return;
        const shouldShow = state.timeSinceStart < 12 && state.loopCount === 0;
        aiPanelGuide.style.opacity = shouldShow ? "0.95" : "0";
      }

      const audioEngine = {
        ctx: null,
        noiseBuffer: null,
        lastLaserTime: 0,
        lastLockTime: 0
      };
      let enemyIdCounter = 0;

      function init() {
        resize();
        window.addEventListener("resize", resize);
        window.addEventListener("keydown", e => {
          primeAudio();
          state.inputs[e.key.toLowerCase()] = true;
          if (!state.running && e.key.toLowerCase() === "r") resetGame();
          if (e.key === "F1") toggleDebugMode();
        });
        window.addEventListener("keyup", e => state.inputs[e.key.toLowerCase()] = false);
        window.addEventListener("pointerdown", primeAudio);
        window.addEventListener("touchstart", primeAudio, { passive: true });
        createStars();
        resetGame();
        initAIPanelLoop();
        requestAnimationFrame(loop);
      }

      function resetGame() {
        state.running = true;
        state.enemies = [];
        state.lasers = [];
        state.explosions = [];
        state.shockwaves = [];
        state.chainReactions = [];
        state.lockedTargets = [];
        state.lockingAnchor = null;
        state.powerMeter = 0;
        state.comboCount = 0;
        state.comboTimer = 0;
        state.superModeActive = false;
        state.superModeTimer = 0;
        state.superReady = false;
        state.superFireTimer = 0;
        state.superShotsRemaining = 0;
        state.homingChainCount = 0;
        state.homingChainTimer = 0;
        state.homingOverheat = 0;
        // 派手演出リセット
        state.superFlashIntensity = 0;
        state.superPsychicWaves = [];
        state.newtypeAuraParticles = [];
        state.superHueShift = 0;
        state.speed = 50;
        state.shield = settings.maxShield;
        state.score = 0;
        message.textContent = "";
        state.messageTimer = 0;
        state.warpPhase = "entry";
        state.warpTimer = 0;
        state.warpIntensity = 1.2;
        state.warpRingTimer = 0;
        state.warpFlashIntensity = 0;
        state.chatterTimer = 0;
        state.nextChatter = 5 + Math.random() * 3;
        state.navLog = [];
        state.warpAnnounceDone = false;
        state.superHinted = false;
        pushComms("FRAME-R01起動、リンクスーツ同期完了");
        pushComms("ロボ砲塔: ロックオンして旗艦ブリッジを落とせ");
        setupStage();
      }

      // 通信ログを追加し、最新数行を表示
      function pushComms(text) {
        state.navLog.push(text);
        if (state.navLog.length > 8) state.navLog.shift();
      }

      function createStars() {
        state.stars = [];
        for (let i = 0; i < settings.starCount; i++) {
          state.stars.push({
            x: (Math.random() - 0.5) * 200,
            y: (Math.random() - 0.5) * 200,
            z: Math.random() * 200 + 50
          });
        }
      }

      function setupStage() {
        // スタート時には敵を持たない状態にし、タイマーで順次湧かせる
        state.enemies = [];
        state.timeSinceStart = 0;
        state.zoneSpawnIndex = 0;
        state.running = true;
        state.formations = {};
        state.chainReactions = [];
        // 起承転結の演出管理もステージ開始時にリセット
        state.rivalSpawned = false;
        state.rivalDefeated = false;
        state.superHinted = false;
      }

      function primeAudio() {
        // ユーザー操作が入ったら即座にAudioContextを用意
        ensureAudioContext();
      }

      function ensureAudioContext() {
        if (typeof window === "undefined") return null;
        const ctor = window.AudioContext || window.webkitAudioContext;
        if (!ctor) return null;
        if (!audioEngine.ctx) {
          audioEngine.ctx = new ctor();
          audioEngine.noiseBuffer = buildNoiseBuffer(audioEngine.ctx);
        }
        if (audioEngine.ctx.state === "suspended") {
          audioEngine.ctx.resume();
        }
        return audioEngine.ctx;
      }

      function buildNoiseBuffer(ctx) {
        const duration = 0.5;
        const buffer = ctx.createBuffer(1, ctx.sampleRate * duration, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          const decay = 1 - i / data.length;
          data[i] = (Math.random() * 2 - 1) * decay;
        }
        return buffer;
      }

      function playLaserSound() {
        const ctx = ensureAudioContext();
        if (!ctx) return;
        const now = ctx.currentTime;
        if (now - audioEngine.lastLaserTime < 0.03) return;
        audioEngine.lastLaserTime = now;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "square";
        osc.frequency.setValueAtTime(720, now);
        osc.frequency.exponentialRampToValueAtTime(320, now + 0.12);
        gain.gain.setValueAtTime(0.23, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.14);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now);
        osc.stop(now + 0.16);
      }

      function playLockOnSound() {
        // ロック完了時の単音「ピ」。短いサイン波のみで構成
        const ctx = ensureAudioContext();
        if (!ctx) return;
        const now = ctx.currentTime;
        if (now - audioEngine.lastLockTime < 0.08) return;
        audioEngine.lastLockTime = now;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(1180, now);
        gain.gain.setValueAtTime(0.14, now);
        gain.gain.linearRampToValueAtTime(0.0, now + 0.09);
        osc.connect(gain).connect(ctx.destination);
        osc.start(now);
        osc.stop(now + 0.1);
      }

      function playHomingSound() {
        // 水流のような誘導レーザーSE: ノイズ＋バンドパスで揺らぎを演出
        const ctx = ensureAudioContext();
        if (!ctx || !audioEngine.noiseBuffer) return;
        const now = ctx.currentTime;
        const noise = ctx.createBufferSource();
        noise.buffer = audioEngine.noiseBuffer;
        const filter = ctx.createBiquadFilter();
        filter.type = "bandpass";
        filter.frequency.setValueAtTime(1800, now);
        filter.frequency.exponentialRampToValueAtTime(520, now + 0.45);
        filter.Q.value = 3.2;
        const lfo = ctx.createOscillator();
        lfo.type = "sine";
        lfo.frequency.value = 6;
        const lfoGain = ctx.createGain();
        lfoGain.gain.value = 260;
        lfo.connect(lfoGain).connect(filter.frequency);
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.08, now);
        gain.gain.linearRampToValueAtTime(0.0, now + 0.5);
        noise.connect(filter).connect(gain).connect(ctx.destination);
        noise.start(now);
        noise.stop(now + 0.52);
        lfo.start(now);
        lfo.stop(now + 0.52);
      }

      function playEnemyRocketSound() {
        const ctx = ensureAudioContext();
        if (!ctx) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const now = ctx.currentTime;
        osc.type = "sawtooth";
        osc.frequency.setValueAtTime(420, now);
        osc.frequency.exponentialRampToValueAtTime(260, now + 0.18);
        gain.gain.setValueAtTime(0.16, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.22);
        const filter = ctx.createBiquadFilter();
        filter.type = "bandpass";
        filter.frequency.value = 600;
        filter.Q.value = 1.2;
        osc.connect(filter).connect(gain).connect(ctx.destination);
        osc.start(now);
        osc.stop(now + 0.24);
      }

      function playExplosionSound(power = 1) {
        const ctx = ensureAudioContext();
        if (!ctx || !audioEngine.noiseBuffer) return;
        const noise = ctx.createBufferSource();
        noise.buffer = audioEngine.noiseBuffer;
        const filter = ctx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.setValueAtTime(800 + power * 500, ctx.currentTime);
        const gain = ctx.createGain();
        const startGain = 0.32 * power;
        gain.gain.setValueAtTime(startGain, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.6);
        noise.connect(filter).connect(gain).connect(ctx.destination);
        noise.start();
        noise.stop(ctx.currentTime + 0.6);
      }

      // ニュータイプ覚醒サウンド - ガンダム風パワーアップ効果音
      function playNewtypeAwakeningSound() {
        const ctx = ensureAudioContext();
        if (!ctx) return;
        const now = ctx.currentTime;
        const masterGain = ctx.createGain();
        masterGain.gain.setValueAtTime(0.35, now);
        masterGain.connect(ctx.destination);

        // レイヤー1: 上昇するサイン波（キィィーン）
        const osc1 = ctx.createOscillator();
        const gain1 = ctx.createGain();
        osc1.type = "sine";
        osc1.frequency.setValueAtTime(800, now);
        osc1.frequency.exponentialRampToValueAtTime(2400, now + 0.6);
        osc1.frequency.exponentialRampToValueAtTime(4800, now + 1.2);
        gain1.gain.setValueAtTime(0.15, now);
        gain1.gain.linearRampToValueAtTime(0.35, now + 0.5);
        gain1.gain.linearRampToValueAtTime(0.0, now + 1.8);
        osc1.connect(gain1).connect(masterGain);
        osc1.start(now);
        osc1.stop(now + 2.0);

        // レイヤー2: パルス波でビーム感（ピィィーン）
        const osc2 = ctx.createOscillator();
        const gain2 = ctx.createGain();
        osc2.type = "triangle";
        osc2.frequency.setValueAtTime(1200, now);
        osc2.frequency.exponentialRampToValueAtTime(3600, now + 0.4);
        osc2.frequency.setValueAtTime(3600, now + 0.4);
        osc2.frequency.exponentialRampToValueAtTime(1800, now + 1.5);
        gain2.gain.setValueAtTime(0.08, now);
        gain2.gain.linearRampToValueAtTime(0.22, now + 0.3);
        gain2.gain.linearRampToValueAtTime(0.0, now + 1.6);
        osc2.connect(gain2).connect(masterGain);
        osc2.start(now);
        osc2.stop(now + 1.8);

        // レイヤー3: ディープなベースパルス（ドォォォン）
        const osc3 = ctx.createOscillator();
        const gain3 = ctx.createGain();
        osc3.type = "sawtooth";
        osc3.frequency.setValueAtTime(80, now);
        osc3.frequency.exponentialRampToValueAtTime(160, now + 0.8);
        osc3.frequency.linearRampToValueAtTime(60, now + 2.0);
        gain3.gain.setValueAtTime(0.2, now);
        gain3.gain.linearRampToValueAtTime(0.4, now + 0.5);
        gain3.gain.exponentialRampToValueAtTime(0.001, now + 2.5);
        const filter3 = ctx.createBiquadFilter();
        filter3.type = "lowpass";
        filter3.frequency.value = 200;
        filter3.Q.value = 2;
        osc3.connect(filter3).connect(gain3).connect(masterGain);
        osc3.start(now);
        osc3.stop(now + 2.6);

        // レイヤー4: 高周波コーラス風（シャキーン）
        for (let i = 0; i < 3; i++) {
          const oscChoir = ctx.createOscillator();
          const gainChoir = ctx.createGain();
          oscChoir.type = "sine";
          const baseFreq = 2000 + i * 400;
          oscChoir.frequency.setValueAtTime(baseFreq, now + 0.2);
          oscChoir.frequency.exponentialRampToValueAtTime(baseFreq * 2, now + 0.8);
          oscChoir.frequency.linearRampToValueAtTime(baseFreq * 1.5, now + 1.5);
          gainChoir.gain.setValueAtTime(0, now);
          gainChoir.gain.linearRampToValueAtTime(0.06, now + 0.3);
          gainChoir.gain.linearRampToValueAtTime(0.1, now + 0.6);
          gainChoir.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
          oscChoir.connect(gainChoir).connect(masterGain);
          oscChoir.start(now + 0.2);
          oscChoir.stop(now + 2.2);
        }

        // レイヤー5: エコー風ディレイ効果（残響）
        const delay = ctx.createDelay(0.5);
        delay.delayTime.value = 0.15;
        const feedback = ctx.createGain();
        feedback.gain.value = 0.25;
        const delayFilter = ctx.createBiquadFilter();
        delayFilter.type = "highpass";
        delayFilter.frequency.value = 1500;
        masterGain.connect(delay);
        delay.connect(feedback);
        feedback.connect(delayFilter);
        delayFilter.connect(delay);
        delay.connect(ctx.destination);

        // レイヤー6: ランダムなスパークリングノート
        for (let i = 0; i < 5; i++) {
          const sparkOsc = ctx.createOscillator();
          const sparkGain = ctx.createGain();
          sparkOsc.type = "sine";
          const sparkTime = now + 0.1 + i * 0.12;
          const sparkFreq = 3000 + Math.random() * 2000;
          sparkOsc.frequency.setValueAtTime(sparkFreq, sparkTime);
          sparkOsc.frequency.exponentialRampToValueAtTime(sparkFreq * 0.7, sparkTime + 0.15);
          sparkGain.gain.setValueAtTime(0.12, sparkTime);
          sparkGain.gain.exponentialRampToValueAtTime(0.001, sparkTime + 0.2);
          sparkOsc.connect(sparkGain).connect(masterGain);
          sparkOsc.start(sparkTime);
          sparkOsc.stop(sparkTime + 0.25);
        }
      }

      // スーパーモード発動時のパーティクル・ウェーブ生成
      function spawnNewtypeAura() {
        // サイキックウェーブを複数生成
        for (let i = 0; i < 5; i++) {
          state.superPsychicWaves.push({
            radius: 0,
            maxRadius: 400 + i * 80,
            speed: 300 + i * 50,
            alpha: 1.0,
            hue: 180 + i * 30
          });
        }
        // オーラパーティクル生成
        for (let i = 0; i < 60; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 100 + Math.random() * 200;
          state.newtypeAuraParticles.push({
            x: canvas.width / 2,
            y: canvas.height / 2,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.5 + Math.random() * 1.0,
            size: 2 + Math.random() * 4,
            hue: 60 + Math.random() * 60 // ゴールド～オレンジ系
          });
        }
      }

      function assignEnemyId(enemy) {
        // 敵個体にIDを付与してロックオンや誘導追尾で参照しやすくする
        enemy.id = (enemyIdCounter += 1);
        return enemy;
      }

      function spawnEnemyRocket(origin, dir, options = {}) {
        // 敵弾をロケット形態に統一し、加速や残光を付与
        const speed = options.speed ?? 8;
        const accel = options.accel ?? 16;
        const maxSpeed = options.maxSpeed ?? 36;
        const rocket = {
          type: "rocket",
          x: origin.x,
          y: origin.y,
          z: origin.z,
          vx: dir.x * speed,
          vy: dir.y * speed,
          vz: dir.z * speed,
          ax: dir.x * accel,
          ay: dir.y * accel,
          az: dir.z * accel,
          maxSpeed,
          trailTimer: 0,
          color: options.color || "#f64",
          glow: options.glow || "#ff8"
        };
        state.enemyShots.push(rocket);
        playEnemyRocketSound();
      }

      function spawnRocketTrail(rocket) {
        // ロケットの残炎を粒子化して視認性を高める
        const backstep = 0.4;
        const px = rocket.x - rocket.vx * backstep * 0.02;
        const py = rocket.y - rocket.vy * backstep * 0.02;
        const pz = rocket.z - rocket.vz * backstep * 0.02;
        state.explosions.push({
          x: px,
          y: py,
          z: pz,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          vz: -8 + Math.random() * 3,
          life: 0.18 + Math.random() * 0.12,
          color: rocket.color || "#f64",
          width: 1.4,
          glow: rocket.glow || "#ff8",
          glowBlur: 6
        });
      }

      function showMessage(text, duration = 3) {
        message.textContent = text;
        state.messageTimer = duration;
      }

      function handleSpawnTimer() {
        while (state.zoneSpawnIndex < stageZones.length) {
          const zone = stageZones[state.zoneSpawnIndex];
          if (state.timeSinceStart < zone.startDelay) break;
          state.zoneSpawnIndex += 1;
          // 章立て（起承転結）をHUDに反映して、今どこかを分かりやすくする
          if (zone.act && zone.label) {
            state.sectorLabel = `ACT ${zone.act} / ${zone.label}`;
          }
          // ゾーン開始時の通信ログ（盛り上げ担当）
          if (zone.comms && Array.isArray(zone.comms)) {
            zone.comms.forEach(line => pushComms(line));
          }
          if (zone.message) {
            // ゾーン固有メッセージで艦隊戦などの山場を通知
            showMessage(zone.message, zone.messageDuration || 3.5);
          }
          spawnZoneFighters(zone);
          if (zone.corvettes) spawnZoneCorvettes(zone);
          if (zone.battleships) spawnZoneBattleships(zone);
          if (zone.dreadnought) spawnZoneDreadnought(zone);
        }
      }

      function updateFormationAnchors(dt) {
        const targetX = state.yaw * 3;
        const targetY = -state.pitch * 1.5;
        const anchorRetreat = settings.formationRetreatBase ?? settings.enemyRetreatBase;
        const relativeForward = state.speed - anchorRetreat;
        Object.keys(state.formations).forEach(id => {
          const formation = state.formations[id];
          formation.anchorX += (targetX - formation.anchorX) * dt * 1.6;
          formation.anchorY += (targetY - formation.anchorY) * dt * 1.2;
          if (relativeForward > 0) {
            const approach = Math.min(relativeForward, settings.maxApproachRate);
            formation.anchorZ -= approach * dt;
          } else if (relativeForward < 0) {
            const recede = Math.min(anchorRetreat, -relativeForward) * settings.enemyRecedeFactor;
            formation.anchorZ += recede * dt;
          }
          if (formation.members <= 0) {
            delete state.formations[id];
          }
        });
      }

      function releaseFormationSlot(enemy) {
        if (!enemy.formationGroup) return;
        const formation = state.formations[enemy.formationGroup];
        if (!formation) return;
        formation.members = Math.max(0, formation.members - 1);
      }

      function loopStage() {
        state.loopCount += 1;
        state.lasers = [];
        state.enemyShots = [];
        state.explosions = [];
        state.shockwaves = [];
        state.chainReactions = [];
        state.lockedTargets = [];
        state.lockingAnchor = null;
        state.powerMeter = 0;
        state.comboCount = 0;
        state.comboTimer = 0;
        state.superModeActive = false;
        state.superModeTimer = 0;
        state.superReady = false;
        state.superFireTimer = 0;
        state.superHinted = false;
        state.homingChainCount = 0;
        state.homingChainTimer = 0;
        state.homingOverheat = 0;
        setupStage();
        showMessage(`STAGE MAP LOOP ${state.loopCount}`, 1.8);
      }

      function spawnZoneFighters(zone) {
        const interval = zone.waveInterval || 18;
        const perGroup = 3;
        for (let wave = 0; wave < zone.fighterWaves; wave++) {
          const waveZ = zone.baseZ - wave * interval;
          const groups = Math.ceil(zone.fightersPerWave / perGroup);
          for (let g = 0; g < groups; g++) {
            const groupId = `fg_${Date.now()}_${Math.random().toString(36).slice(2, 5)}`;
            state.formations[groupId] = {
              anchorX: 0,
              anchorY: 0,
              anchorZ: waveZ,
              members: 0
            };
            for (let r = 0; r < perGroup; r++) {
              const index = g * perGroup + r;
              if (index >= zone.fightersPerWave) break;
              const offsetX = (r - 1) * 6 + (g - groups / 2) * 8;
              const offsetY = (r - 1) * 3;
              const fighter = createFighter(
                offsetX + (Math.random() - 0.5) * 4,
                offsetY + (Math.random() - 0.5) * 6,
                waveZ + (Math.random() - 0.5) * 6
              );
              fighter.formationGroup = groupId;
              fighter.formationOffset = { x: offsetX, y: offsetY };
              state.formations[groupId].members += 1;
              state.enemies.push(fighter);
            }
          }
        }
      }

      function spawnZoneCorvettes(zone) {
        const distanceStep = 6;
        for (let i = 0; i < zone.corvettes; i++) {
          const offsetX = (Math.random() - 0.5) * 30;
          const offsetY = (Math.random() - 0.5) * 20;
          const offsetZ = zone.baseZ - i * distanceStep;
          state.enemies.push(createEscort(offsetX, offsetY, offsetZ));
        }
      }

      function spawnZoneBattleships(zone) {
        const spacing = zone.battleSpacing || 22;
        const shipCount = zone.battleshipCount ?? stageConfig.battleships;
        for (let i = 0; i < shipCount; i++) {
          const lane = i - (shipCount - 1) / 2;
          const baseX = lane * 26;
          const baseY = (Math.random() - 0.5) * 32;
          const baseZ = zone.baseZ - i * spacing;
          const ship = createBattleship(baseX, baseY, baseZ);
          state.enemies.push(ship);
          const escorts = zone.escortsPerShip ?? stageConfig.escortsPerShip;
          // ゾーンごとに護衛艦の列数を増やし、後半の密度を底上げ
          for (let e = 0; e < escorts; e++) {
            const offsetX = baseX + (e % 2 === 0 ? -10 : 10);
            const offsetY = baseY + (e === 0 ? -6 : 6);
            const offsetZ = baseZ + 10 + e * 4;
            state.enemies.push(createEscort(offsetX, offsetY, offsetZ));
          }
          const ringCount = zone.fleetEscortRing ?? 0;
          if (ringCount > 0) {
            // 螺旋状の追加護衛で艦隊戦らしい包囲感を演出
            const radius = zone.fleetEscortRadius ?? 20;
            const offsetZ = zone.fleetEscortOffsetZ ?? 8;
            for (let r = 0; r < ringCount; r++) {
              const angle = (Math.PI * 2 * r) / ringCount;
              const escortX = baseX + Math.cos(angle) * radius;
              const escortY = baseY + Math.sin(angle) * radius * 0.6;
              const escortZ = baseZ + offsetZ + r * 1.1;
              const ringEscort = createEscort(escortX, escortY, escortZ);
              ringEscort.vx *= 0.4;
              ringEscort.vy *= 0.4;
              state.enemies.push(ringEscort);
            }
          }
        }
      }

      function spawnZoneDreadnought(zone) {
        const baseX = 0;
        const baseY = (Math.random() - 0.5) * 14;
        const baseZ = zone.baseZ || 150;
        const dread = createDreadnought(baseX, baseY, baseZ);
        state.enemies.push(dread);
        const escorts = zone.dreadnoughtEscorts ?? stageConfig.dreadnoughtEscorts;
        for (let i = 0; i < escorts; i++) {
          const angle = (Math.PI * 2 * i) / escorts;
          const radius = 22 + (i % 2) * 5;
          const offsetX = baseX + Math.cos(angle) * radius;
          const offsetY = baseY + Math.sin(angle) * radius * 0.6;
          const offsetZ = baseZ + 8 + i * 3;
          state.enemies.push(createEscort(offsetX, offsetY, offsetZ));
        }
        showMessage("FLAGSHIP DETECTED - DESTROY CORE", 4.5);
      }

      function triggerRivalArrival(flagship) {
        // 「転」要素: 有利になった瞬間にライバルが乱入してテンションを上げる
        if (state.rivalSpawned || state.rivalDefeated) return;
        state.rivalSpawned = true;
        showMessage("RIVAL UNIT INBOUND", 3.6);
        pushComms("???: ここからは俺が相手だ");
        pushComms("管制: ライバル機反応！旗艦と同時に来るぞ！");
        const spawnZ = Math.max(180, (flagship?.z ?? 200) + 70);
        const rival = createRivalWeapon((Math.random() - 0.5) * 40, (Math.random() - 0.5) * 18, spawnZ);
        rival.flash = 0.6;
        state.enemies.push(rival);
      }

      function createFighter(x, y, z) {
        const profile = getEnemyFireProfile();
        return assignEnemyId({
          type: "fighter",
          code: "FIGHTR",
          x: x ?? (Math.random() - 0.5) * 120,
          y: y ?? (Math.random() - 0.5) * 80,
          z: z ?? 320,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 4,
          retreatSpeed: settings.enemyRetreatBase + Math.random() * 6,
          maxApproachRate: settings.maxApproachRate + Math.random() * 2,
          flash: 0,
          fireTimer: Math.random() * profile.maxDelay,
          fireDelay: profile.minDelay + Math.random() * (profile.maxDelay - profile.minDelay),
          retired: false,
          pendingExplosion: false,
          pendingExplosionColor: "#f0f",
          pendingExplosionScore: 100,
          pendingMegaExplosion: false,
          megaExplosionHandler: null,
          scoreAwarded: false
        });
      }

      function createRivalWeapon(x, y, z) {
        // ライバルのロボット兵器（旗艦戦の盛り上げ役）。多段ヒットで手応えを出す。
        return assignEnemyId({
          type: "rival",
          code: "RIVAL",
          x: x ?? (Math.random() - 0.5) * 60,
          y: y ?? (Math.random() - 0.5) * 36,
          z: z ?? 230,
          vx: 0,
          vy: 0,
          retreatSpeed: 20,
          maxApproachRate: 32,
          recedeFactor: 0.28,
          flash: 0,
          hp: 6,
          maxHp: 6,
          age: 0,
          phase: Math.random() * Math.PI * 2,
          fireTimer: 0,
          fireDelay: 1.0,
          // 回避AI: 無限回避は不公平なので、エネルギー制で「長く戦える」を作る
          evadeEnergy: 100,
          evadeEnergyMax: 100,
          evadeRegen: 22, // 1秒あたり回復量
          evadeCost: 26, // 1回の緊急回避コスト
          evadeCooldown: 0,
          phaseShift: 0, // 短時間だけ当たり判定をすり抜ける（演出+理不尽回避）
          retired: false,
          pendingExplosion: false,
          pendingExplosionColor: "#ff4d4d",
          pendingExplosionScore: 650,
          pendingMegaExplosion: false,
          megaExplosionHandler: null,
          scoreAwarded: false,
          explosionDelay: 0
        });
      }

      function createEscort(x, y, z) {
        const profile = getEnemyFireProfile();
        return assignEnemyId({
          type: "corvette",
          code: "CORVET",
          x,
          y,
          z,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 0.5) * 3,
          retreatSpeed: settings.enemyRetreatBase - 2 + Math.random() * 4,
          maxApproachRate: settings.maxApproachRate - 2 + Math.random() * 2,
          recedeFactor: settings.enemyRecedeFactor,
          phase: Math.random() * Math.PI * 2,
          flash: 0,
          fireTimer: Math.random() * profile.maxDelay,
          fireDelay: profile.minDelay + Math.random() * (profile.maxDelay - profile.minDelay),
          retired: false,
          pendingExplosion: false,
          pendingExplosionColor: "#0f9",
          pendingExplosionScore: 150,
          pendingMegaExplosion: false,
          megaExplosionHandler: null,
          scoreAwarded: false
        });
      }

      function createBattleship(baseX, baseY, baseZ) {
        const profile = getEnemyFireProfile();
        const segments = [];
        const segmentCount = 4;
        const spacing = 16;
        for (let i = 0; i < segmentCount; i++) {
          const lockable = i < 3; // 大型艦専用の三つのロックオン箇所を先頭3セグメントに割り当て
          segments.push({
            offsetX: (Math.random() - 0.5) * 4,
            offsetY: (Math.random() - 0.5) * 3,
            offsetZ: i * spacing,
            destroyed: false,
            hp: lockable ? 1 : 2 + Math.floor(Math.random() * 3),
            size: i === 0 ? 11 : 9,
            lockable,
            lockKey: lockable ? `batt_hp_${i}` : undefined
          });
        }
        return assignEnemyId({
          type: "battleship",
          x: baseX ?? (Math.random() - 0.5) * 100,
          y: baseY ?? (Math.random() - 0.5) * 60,
          z: baseZ ?? 340,
          retreatSpeed: 24 + Math.random() * 4,
          maxApproachRate: 26,
          recedeFactor: 0.38,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 3,
          flash: 0,
          segments
          ,
          fireTimer: Math.random() * profile.maxDelay,
          fireDelay: profile.minDelay + Math.random() * (profile.maxDelay - profile.minDelay),
          retired: false,
          pendingExplosion: false,
          pendingExplosionColor: "#fff",
          pendingExplosionScore: 200,
          pendingMegaExplosion: false,
          megaExplosionHandler: null,
          scoreAwarded: false,
          explosionDelay: 0,
          cumulativeDamage: 0,
          damageThreshold: segmentCount * 45
        });
      }

      function createDreadnought(baseX, baseY, baseZ) {
        const blueprint = [ // 旗艦の装甲にも三点ロックルールを反映
          { key: "engineL", offsetX: -18, offsetY: 5, offsetZ: -24, hp: 1, size: 12, score: 200, turret: true, fireDelay: 2.8, neighbors: ["hangar", "shield"], lockable: true },
          { key: "engineR", offsetX: 18, offsetY: 5, offsetZ: -24, hp: 1, size: 12, score: 200, turret: true, fireDelay: 2.8, neighbors: ["hangar", "shield"], lockable: true },
          { key: "hangar", offsetX: 0, offsetY: 9, offsetZ: -8, hp: 4, size: 14, score: 260, turret: true, fireDelay: 2.4, neighbors: ["engineL", "engineR", "shield", "bridge"] },
          { key: "shield", offsetX: 0, offsetY: 0, offsetZ: -4, hp: 4, size: 15, score: 280, generator: true, neighbors: ["engineL", "engineR", "hangar", "bridge", "core"] },
          { key: "bridge", offsetX: 0, offsetY: -6, offsetZ: 10, hp: 3, size: 12, score: 320, requires: ["shield"], turret: true, fireDelay: 3.2, neighbors: ["hangar", "shield", "core"] },
          { key: "core", offsetX: 0, offsetY: 0, offsetZ: 22, hp: 1, size: 10, score: 900, requires: ["engineL", "engineR", "hangar", "bridge"], final: true, neighbors: ["bridge", "shield"], lockable: true }
        ];
        const segments = blueprint.map(seg => ({
          ...seg,
          destroyed: false
        }));
        const segmentMap = {};
        for (const segment of segments) {
          segmentMap[segment.key] = segment;
        }
        return assignEnemyId({
          type: "dreadnought",
          x: baseX ?? (Math.random() - 0.5) * 40,
          y: baseY ?? (Math.random() - 0.5) * 24,
          z: baseZ ?? 360,
          vx: 0,
          vy: 0,

          retreatSpeed: 18,
          maxApproachRate: 20,
          recedeFactor: 0.32,

          flash: 0,
          segments,
          segmentMap,
          fireTimer: 0,
          fireDelay: 3,
          turretTimers: {},
          retired: false,
          pendingExplosion: false,
          pendingExplosionColor: "#fff",
          pendingExplosionScore: 900,
          pendingMegaExplosion: false,
          megaExplosionHandler: null,
          scoreAwarded: false,
          explosionDelay: 0,
          driftPhase: Math.random() * Math.PI * 2,
          coreAnnounced: false,
          // 航空母艦らしく戦闘機を継続発艦させるための管理フラグ
          carrierTag: `carrier_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`,
          carrierLaunchTimer: 0,
          carrierLaunchInterval: 2.8,
          carrierLaunchBurst: 4,
          carrierMaxActive: 12,
          carrierLaunchAnnounced: false
        });
      }

      function handleCarrierLaunch(enemy, dt) {
        // ハンガーが健在な間は一定間隔で戦闘機を甲板から発進させる
        if (enemy.pendingExplosion) return;
        const hangar = enemy.segmentMap?.hangar;
        if (!hangar || hangar.destroyed) return;
        enemy.carrierLaunchTimer = (enemy.carrierLaunchTimer || 0) + dt;
        const interval = enemy.carrierLaunchInterval || 3.2;
        if (enemy.carrierLaunchTimer < interval) return;
        const maxActive = enemy.carrierMaxActive || 12;
        const active = countCarrierFighters(enemy);
        if (active >= maxActive) return;
        enemy.carrierLaunchTimer = 0;
        const spawnTotal = Math.min(enemy.carrierLaunchBurst || 3, maxActive - active);
        if (spawnTotal <= 0) return;
        if (!enemy.carrierLaunchAnnounced) {
          showMessage("CARRIER DECK LAUNCH - INTERCEPT", 3.2);
          enemy.carrierLaunchAnnounced = true;
        }
        for (let i = 0; i < spawnTotal; i++) {
          state.enemies.push(spawnCarrierFighter(enemy, hangar, i, spawnTotal));
        }
      }

      function countCarrierFighters(enemy) {
        const tag = enemy.carrierTag;
        if (!tag) return 0;
        let active = 0;
        for (const foe of state.enemies) {
          if (foe.type === "fighter" && foe.carrierTag === tag && !foe.retired && !foe.pendingExplosion) {
            active += 1;
          }
        }
        return active;
      }

      function spawnCarrierFighter(enemy, hangarSegment, index, total) {
        // ハンガー口から扇状に飛び出すように座標と速度を付与
        const segPos = segmentWorldPosition(enemy, hangarSegment);
        const spread = (index - (total - 1) / 2) * 4;
        const fighter = createFighter(
          segPos.x + spread + (Math.random() - 0.5) * 2.4,
          segPos.y - 2 + (Math.random() - 0.5) * 2,
          segPos.z + 8 + Math.random() * 4
        );
        fighter.carrierTag = enemy.carrierTag;
        fighter.vx += (Math.random() - 0.5) * 2;
        fighter.vy += -4 - Math.random() * 2;
        fighter.retreatSpeed = Math.max(18, fighter.retreatSpeed - 4);
        fighter.maxApproachRate += 4;
        fighter.flash = 0.35;
        fighter.carrierOrbital = true;
        fighter.orbitAngle = Math.random() * Math.PI * 2;
        fighter.orbitSpeed = 0.9 + Math.random() * 0.9;
        fighter.orbitRadius = 14 + Math.random() * 8;
        fighter.orbitHeight = 6 + Math.random() * 5;
        fighter.carrierPhase = "orbit";
        fighter.carrierPhaseTimer = 0;
        fighter.carrierOrbitDuration = 1.8 + Math.random() * 1.6;
        fighter.carrierDiveBias = Math.random() * 0.8 - 0.4;
        fighter.carrierRoll = 0;
        return fighter;
      }

      function updateCarrierInterceptor(enemy, dt) {
        // フェーズ制で周遊→急降下→上昇に遷移させて戦闘機らしい挙動を再現
        enemy.carrierPhaseTimer = (enemy.carrierPhaseTimer || 0) + dt;
        enemy.orbitAngle = (enemy.orbitAngle || 0) + dt * (enemy.orbitSpeed || 1.1);
        const baseX = state.yaw * 2.6;
        const baseY = -state.pitch * 1.4;
        const radius = enemy.orbitRadius || 16;
        const phase = enemy.carrierPhase || "orbit";
        if (phase === "orbit") {
          const desiredX = baseX + Math.cos(enemy.orbitAngle) * radius;
          const desiredY = baseY + Math.sin(enemy.orbitAngle) * radius * 0.7;
          const desiredZ = 70 + Math.sin(enemy.orbitAngle * 1.35) * (enemy.orbitHeight || 8);
          enemy.vx += (desiredX - enemy.x) * dt * 7.2;
          enemy.vy += (desiredY - enemy.y) * dt * 7.2;
          enemy.z += (desiredZ - enemy.z) * dt * 4.8;
          enemy.vx += Math.cos(enemy.orbitAngle + Math.PI / 2) * 2.4 * dt;
          enemy.vy += Math.sin(enemy.orbitAngle + Math.PI / 2) * 2.4 * dt;
          const desiredRoll = Math.sin(enemy.orbitAngle * 1.2) * 28;
          const currentRoll = enemy.carrierRoll || 0;
          enemy.carrierRoll = currentRoll + (desiredRoll - currentRoll) * dt * 2.8;
          if (enemy.carrierPhaseTimer > (enemy.carrierOrbitDuration || 2.2)) {
            enemy.carrierPhase = "dive";
            enemy.carrierPhaseTimer = 0;
          }
        } else if (phase === "dive") {
          const targetX = state.yaw * 0.6 + enemy.carrierDiveBias;
          const targetY = -state.pitch * 0.6;
          const targetZ = 22;
          enemy.vx += (targetX - enemy.x) * dt * 9.5;
          enemy.vy += (targetY - enemy.y) * dt * 9.5;
          enemy.z += (targetZ - enemy.z) * dt * 8.2;
          enemy.carrierRoll = Math.min(55, (enemy.carrierRoll || 0) + dt * 180);
          if (enemy.carrierPhaseTimer > 1.6 || enemy.z < 26) {
            enemy.carrierPhase = "climb";
            enemy.carrierPhaseTimer = 0;
          }
        } else {
          const climbTargetZ = 80;
          const lateralDrift = Math.sin(enemy.orbitAngle) * radius * 0.4;
          enemy.vx += (baseX + lateralDrift - enemy.x) * dt * 6.4;
          enemy.vy += (baseY - lateralDrift * 0.5 - enemy.y) * dt * 6.4;
          enemy.z += (climbTargetZ - enemy.z) * dt * 5.2;
          enemy.carrierRoll = Math.max(0, (enemy.carrierRoll || 0) - dt * 160);
          if (enemy.carrierPhaseTimer > 1.4) {
            enemy.carrierPhase = "orbit";
            enemy.carrierPhaseTimer = 0;
            enemy.carrierOrbitDuration = 1.6 + Math.random() * 1.8;
          }
        }
      }

      function updateFormationFighterFlight(enemy, dt, formationTarget) {
        // フォーメーション戦闘機をなめらかなバンク＆ノーズ制御で飛ばす
        const aimX = formationTarget ? formationTarget.x : state.yaw * 3.2;
        const aimY = formationTarget ? formationTarget.y : -state.pitch * 2;
        const desiredVX = (aimX - enemy.x) * 2.6;
        const desiredVY = (aimY - enemy.y) * 2.0;
        enemy.vx += (desiredVX - enemy.vx) * dt * 4.1;
        enemy.vy += (desiredVY - enemy.vy) * dt * 3.8;
        enemy.vy += Math.sin(enemy.age * 2.3) * dt * 1.4;
        const bankTarget = Math.max(-50, Math.min(50, (desiredVX - enemy.vx) * 2.2));
        const currentRoll = enemy.flightRoll || 0;
        enemy.flightRoll = currentRoll + (bankTarget - currentRoll) * dt * 5.4;
        enemy.vx += Math.cos(enemy.age * 1.2 + enemy.flightRoll * 0.05) * dt * 0.8;
      }

      function handleInput(dt) {
        // 入力状態から機体姿勢と速度を更新
        const a = state.inputs;
        const agility = a["shift"] ? settings.agilityQuick : settings.agilityBase;
        const turnSpeed = agility * dt;
        const yawDir = (a["arrowleft"] || a["a"]) ? 1 : (a["arrowright"] || a["d"]) ? -1 : 0;
        const pitchDir = (a["arrowup"] || a["w"]) ? 1 : (a["arrowdown"] || a["s"]) ? -1 : 0;
        const manualRoll = (a["q"] ? 1 : 0) - (a["e"] ? 1 : 0);
        const rollTarget = yawDir * 30 + manualRoll * 25;
        state.roll += (rollTarget - state.roll) * dt * settings.rollReturn;
        if (yawDir !== 0) {
          state.yaw += (turnSpeed + Math.abs(state.roll) * 0.005) * yawDir;
        }
        state.yaw += state.roll * settings.rollYawInfluence * dt;
        if (pitchDir !== 0) {
          state.pitch += turnSpeed * pitchDir;
        }
        if (a["shift"]) state.speed = Math.min(settings.maxSpeed, state.speed + 60 * dt);
        else if (a["control"]) state.speed = Math.max(settings.minSpeed, state.speed - 60 * dt);
        if (a[" "]) {
          fireTwinBeams();
          a[" "] = false;
        }
        if (a["enter"]) {
          fireHomingBurst();
          a["enter"] = false;
        }
        if (a["x"]) {
          if (state.superReady) tryActivateSuperMode();
          else fireHomingBurst();
          a["x"] = false;
        }
      }

      const largeEnemyTypes = new Set(["battleship", "dreadnought"]);

      function isLargeEnemy(enemy) {
        return Boolean(enemy && largeEnemyTypes.has(enemy.type));
      }

      function makeLockKey(enemy, anchorKey) {
        return `${enemy?.id ?? "null"}:${anchorKey}`;
      }

      function ensureLockProgressMap(enemy) {
        enemy.lockProgressMap = enemy.lockProgressMap || {};
        return enemy.lockProgressMap;
      }

      function getLockProgress(enemy, anchorKey = "core") {
        const map = ensureLockProgressMap(enemy);
        return map[anchorKey] || 0;
      }

      function setLockProgress(enemy, anchorKey = "core", value = 0) {
        const map = ensureLockProgressMap(enemy);
        map[anchorKey] = Math.max(0, value);
      }

      function clearLockProgress(enemy, anchorKey = "core") {
        if (!enemy?.lockProgressMap) return;
        enemy.lockProgressMap[anchorKey] = 0;
      }

      function getSegmentLockKey(segment, fallbackIndex = 0) {
        if (!segment) return null;
        if (segment.lockKey) return segment.lockKey;
        if (segment.key) return segment.key;
        return `seg_${fallbackIndex}`;
      }

      function getAnchorPosition(enemy, anchorKey = "core") {
        if (!enemy) return null;
        if (isLargeEnemy(enemy) && enemy.segments) {
          for (let i = 0; i < enemy.segments.length; i++) {
            const segment = enemy.segments[i];
            if (!segment || segment.destroyed) continue;
            if (getSegmentLockKey(segment, i) === anchorKey) {
              return segmentWorldPosition(enemy, segment);
            }
          }
        }
        return { x: enemy.x, y: enemy.y, z: enemy.z };
      }

      function collectLockCandidates() {
        // 大型敵は弱点セグメント単位、小型は機体中心をロック対象として扱う
        const candidates = [];
        for (const enemy of state.enemies) {
          if (!enemy || enemy.retired || enemy.pendingExplosion) continue;
          if (isLargeEnemy(enemy) && enemy.segments) {
            enemy.segments.forEach((segment, idx) => {
              if (!segment || segment.destroyed) return;
              if (!segment.lockable) return;
              if (isSegmentLocked(enemy, segment)) return;
              const world = segmentWorldPosition(enemy, segment);
              if (!world || world.z <= lockSettings.minDepth) return;
              const anchorKey = getSegmentLockKey(segment, idx);
              candidates.push({ enemy, anchorKey, anchorId: makeLockKey(enemy, anchorKey), world });
            });
            continue;
          }
          const anchorKey = "core";
          const world = { x: enemy.x, y: enemy.y, z: enemy.z };
          if (world.z <= lockSettings.minDepth) {
            world.z = lockSettings.minDepth + 0.01; // 投影が極端にならないよう最小深度を確保
          }
          candidates.push({ enemy, anchorKey, anchorId: makeLockKey(enemy, anchorKey), world });
        }
        return candidates;
      }

      function selectNearestAnchors(limit, excludeKeys = new Set()) {
        // 自動誘導が優先して狙う弱点を距離順に抽出
        const candidates = (collectLockCandidates() || []).filter(candidate => !excludeKeys.has(candidate.anchorId));
        candidates.sort((a, b) => (a.world?.z || 0) - (b.world?.z || 0));
        return candidates.slice(0, limit).map(candidate => ({ enemy: candidate.enemy, anchorKey: candidate.anchorKey }));
      }

      function fireHomingBurst() {
        // ホーミング射撃専用トリガー（通常ショットと分離）
        if (!state.superModeActive && state.homingOverheat > 0) {
          // 冷却中は射撃を拒否してHUD演出だけ行う
          state.lockPulse = (state.lockPulse + 0.2) % 10;
          showMessage("H-LASER COOLING", 1.0);
          return;
        }
        const targets = gatherVolleyTargets();
        if (targets.length === 0) {
          if (!state.superModeActive) {
            state.lockPulse = (state.lockPulse + 0.2) % 10;
          }
          return;
        }
        fireHomingVolley(targets);
        consumeLocks(targets);
        registerHomingHeat();
      }

      function tryActivateSuperMode() {
        if (!state.superReady || state.superModeActive || state.warpPhase !== "combat") return;
        activateSuperMode();
      }

      function fireTwinBeams() {
        // ロボの通常射撃: 従来のツインレーザーで最低限の火力を維持
        const baseVz = state.speed + 120;
        const offsets = [-3.5, 3.5];
        offsets.forEach(offset => {
          state.lasers.push({
            type: "beam",
            x: state.yaw * 0.2 + offset,
            y: -state.pitch * 0.2,
            z: 10,
            vz: baseVz
          });
        });
        playLaserSound();
      }

      function fireHomingVolley(targets) {
        // ロック済み目標へ順番に誘導レーザーを射出
        targets.forEach((target, index) => {
          spawnHomingLaser(target, index * lockSettings.volleyDelayStep);
        });
        playHomingSound();
      }

      function spawnHomingLaser(lockTarget, delay = 0) {
        if (!lockTarget || !lockTarget.enemy) return;
        const enemy = lockTarget.enemy;
        const anchorKey = lockTarget.anchorKey || "core";
        state.lasers.push({
          type: "homing",
          targetId: enemy.id,
          anchorKey,
          x: state.yaw * 0.3,
          y: -state.pitch * 0.25,
          z: 12,
          vx: 0,
          vy: 0,
          vz: state.speed + 40,
          speed: 160,
          turnRate: 7,
          delay,
          life: 4,
          trailTimer: 0,
          tailRecordTimer: 0,
          ribbon: []
        });
      }

      function gatherVolleyTargets() {
        if (state.superModeActive) {
          return selectNearestAnchors(superSettings.autoLockMax);
        }
        const validLocks = [];
        for (const lock of state.lockedTargets) {
          const enemy = lock.enemy || getEnemyById(lock.enemyId);
          if (!enemy) continue;
          validLocks.push({ enemy, anchorKey: lock.anchorKey || "core" });
          if (validLocks.length >= lockSettings.maxTargets) break;
        }
        return validLocks;
      }

      function registerHomingHeat() {
        // 5連発でオーバーヒートする簡易ヒートゲージ
        if (state.superModeActive) {
          state.homingOverheat = 0;
          state.homingChainCount = 0;
          state.homingChainTimer = 0;
          return;
        }
        state.homingChainCount = Math.min(homingWeaponSettings.maxChain, state.homingChainCount + 1);
        state.homingChainTimer = homingWeaponSettings.chainWindow;
        if (state.homingChainCount >= homingWeaponSettings.maxChain) {
          state.homingOverheat = homingWeaponSettings.overheatCooldown;
          state.homingChainCount = 0;
          state.homingChainTimer = 0;
          showMessage("H-LASER OVERHEAT", 1.6);
          pushComms("兵装: 誘導レーザー冷却サイクルに入った");
        }
      }

      function updateHomingHeat(dt) {
        // 射撃間隔が空けばヒートを自然減衰させる
        if (state.superModeActive) {
          state.homingOverheat = 0;
          state.homingChainCount = 0;
          state.homingChainTimer = 0;
          return;
        }
        if (state.homingOverheat > 0) {
          state.homingOverheat = Math.max(0, state.homingOverheat - dt);
          return;
        }
        if (state.homingChainTimer > 0) {
          state.homingChainTimer = Math.max(0, state.homingChainTimer - dt);
          if (state.homingChainTimer === 0) {
            state.homingChainCount = 0;
          }
        }
      }

      function consumeLocks(targets) {
        if (!targets.length) return;
        const consumeKeys = new Set(
          targets.map(target => makeLockKey(target.enemy, target.anchorKey || "core"))
        );
        state.lockedTargets = state.lockedTargets.filter(lock => !consumeKeys.has(lock.key));
        for (const target of targets) {
          if (!target.enemy) continue;
          clearLockProgress(target.enemy, target.anchorKey || "core");
        }
      }

      function getEnemyById(id) {
        if (!id) return null;
        for (const enemy of state.enemies) {
          if (enemy.id === id && !enemy.retired && !enemy.pendingExplosion) {
            return enemy;
          }
        }
        return null;
      }

      function updateLockOn(dt) {
        if (state.warpPhase !== "combat") {
          state.lockedTargets = [];
          state.lockingAnchor = null;
          return;
        }
        if (state.superModeActive) {
          const autoLocks = selectNearestAnchors(Math.max(lockSettings.maxTargets, superSettings.autoLockMax));
          state.lockedTargets = autoLocks.slice(0, lockSettings.maxTargets).map(target => ({
            key: makeLockKey(target.enemy, target.anchorKey),
            enemyId: target.enemy.id,
            anchorKey: target.anchorKey,
            enemy: target.enemy,
            acquiredAt: Date.now()
          }));
          state.lockingAnchor = null;
          state.lockPulse = (state.lockPulse + dt) % 10;
          return;
        }
        state.lockPulse = (state.lockPulse + dt) % 10;
        state.lockingAnchor = null;
        state.lockedTargets = state.lockedTargets
          .map(lock => {
            const enemy = getEnemyById(lock.enemyId || lock.id);
            if (!enemy) return null;
            const anchorPos = getAnchorPosition(enemy, lock.anchorKey || "core");
            if (!anchorPos) return null;
            return { ...lock, enemy };
          })
          .filter(Boolean);
        let capacity = lockSettings.maxTargets - state.lockedTargets.length;
        const lockedKeySet = new Set(state.lockedTargets.map(lock => lock.key));
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const candidates = collectLockCandidates() || [];
        for (const candidate of candidates) {
          const enemy = candidate.enemy;
          const anchorKey = candidate.anchorKey;
          const key = candidate.anchorId;
          const proj = project(candidate.world);
          const dist = Math.hypot(proj.x - cx, proj.y - cy);
          const alreadyLocked = lockedKeySet.has(key);
          if (dist <= lockSettings.radius) {
            if (alreadyLocked) {
              setLockProgress(enemy, anchorKey, lockSettings.holdTime);
              continue;
            }
            if (capacity <= 0) {
              const decayed = Math.max(0, getLockProgress(enemy, anchorKey) - dt * lockSettings.decayRate);
              setLockProgress(enemy, anchorKey, decayed);
              continue;
            }
            setLockProgress(enemy, anchorKey, lockSettings.holdTime);
            addLockTarget(candidate);
            lockedKeySet.add(key);
            capacity -= 1;
          } else {
            const decayed = Math.max(0, getLockProgress(enemy, anchorKey) - dt * lockSettings.decayRate);
            setLockProgress(enemy, anchorKey, decayed);
          }
        }
      }

      function addLockTarget(candidate) {
        // ロック候補単位でユニークな弱点を保持
        if (!candidate || !candidate.enemy) return;
        const key = candidate.anchorId || makeLockKey(candidate.enemy, candidate.anchorKey);
        if (state.lockedTargets.some(lock => lock.key === key)) return;
        if (state.lockedTargets.length >= lockSettings.maxTargets) return;
        state.lockedTargets.push({
          key,
          enemyId: candidate.enemy.id,
          anchorKey: candidate.anchorKey,
          enemy: candidate.enemy,
          acquiredAt: Date.now()
        });
        setLockProgress(candidate.enemy, candidate.anchorKey, lockSettings.holdTime);
        playLockOnSound();
      }

      function registerPlayerKill(enemy, bonus = 0) {
        // 撃破数とパワーゲージを連動させる
        if (!enemy || enemy.killCredited) return;
        enemy.killCredited = true;
        state.comboTimer = powerSettings.comboWindow;
        state.comboCount = Math.min(9, state.comboCount + 1);
        const typeBonus = enemy.type === "dreadnought" ? 20 : enemy.type === "battleship" ? 14 : enemy.type === "corvette" ? 8 : 4;
        const gain = powerSettings.killBase + state.comboCount * powerSettings.comboBonus + typeBonus + bonus;
        addPowerCharge(gain);
      }

      function gainPowerFromHit(amount) {
        // 被弾時もエネルギーが沸騰する演出
        const scaled = powerSettings.hitBase + amount * 0.4;
        state.comboCount = 0;
        state.comboTimer = 0;
        addPowerCharge(scaled);
      }

      function addPowerCharge(amount) {
        if (state.superModeActive || state.superReady) return;
        state.powerMeter = Math.min(powerSettings.maxPower, state.powerMeter + amount);
        if (state.powerMeter >= powerSettings.maxPower) {
          state.powerMeter = powerSettings.maxPower;
          if (canReadySuper()) {
            state.superReady = true;
            state.superHinted = false;
            showMessage("SUPER READY - PRESS X", 2.8);
            pushComms("コア: 超誘導システム安定、覚醒準備完了");
          } else if (!state.superHinted) {
            state.superHinted = true;
            showMessage(`POWER MAX - KEEP COMBO x${powerSettings.superComboMin}+`, 2.4);
            pushComms("コア: 充填は最大…だが不安定、連続撃破で安定化せよ");
          }
        }
      }

      function activateSuperMode() {
        // ニュータイプ覚醒！ ロボの誘導レーザーが撃ち放題になる超過負荷状態
        state.superModeActive = true;
        state.superModeTimer = powerSettings.superDuration;
        state.superFireTimer = 0;
        state.superReady = false;
        state.powerMeter = powerSettings.maxPower;
        state.homingOverheat = 0;
        state.homingChainCount = 0;
        state.homingChainTimer = 0;
        state.superShotsRemaining = superSettings.autoShotLimit;
        // 派手な演出を発動
        state.superFlashIntensity = 1.0; // フラッシュ強度
        state.superHueShift = 0; // 色相シフト開始
        playNewtypeAwakeningSound(); // ガンダム風覚醒音
        spawnNewtypeAura(); // サイキックウェーブ・パーティクル
        showMessage("★ NEWTYPE OVERDRIVE ★", 3.5);
        pushComms("【覚醒】ニュータイプ能力解放、全敵機ロックオン！");
      }

      function endSuperMode() {
        if (!state.superModeActive) return;
        state.superModeActive = false;
        state.superModeTimer = 0;
        state.powerMeter = 0;
        state.superFireTimer = 0;
        state.superReady = false;
        state.superShotsRemaining = 0;
      }

      function updatePowerState(dt) {
        if (state.comboTimer > 0) {
          state.comboTimer -= dt;
          if (state.comboTimer <= 0) {
            state.comboCount = 0;
          }
        }
        if (state.superModeActive) {
          state.superModeTimer -= dt;
          if (state.superModeTimer <= 0) {
            endSuperMode();
          }
          return;
        }
        if (!state.superReady && state.powerMeter >= powerSettings.maxPower && canReadySuper()) {
          state.superReady = true;
          state.superHinted = false;
          showMessage("SUPER READY - PRESS X", 2.2);
          pushComms("コア: 条件達成、覚醒可能");
        }
      }

      // スーパーモード派手エフェクトの更新
      function updateSuperModeEffects(dt) {
        // フラッシュ減衰
        if (state.superFlashIntensity > 0) {
          state.superFlashIntensity = Math.max(0, state.superFlashIntensity - dt * 1.2);
        }

        // サイキックウェーブ更新
        for (const wave of state.superPsychicWaves) {
          wave.radius += wave.speed * dt;
          wave.alpha = Math.max(0, 1 - wave.radius / wave.maxRadius);
        }
        state.superPsychicWaves = state.superPsychicWaves.filter(w => w.alpha > 0);

        // オーラパーティクル更新
        for (const p of state.newtypeAuraParticles) {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.life -= dt;
          // パーティクルがゆっくり減速
          p.vx *= 0.98;
          p.vy *= 0.98;
        }
        state.newtypeAuraParticles = state.newtypeAuraParticles.filter(p => p.life > 0);

        // スーパーモード中の色相シフト
        if (state.superModeActive) {
          state.superHueShift += dt * 120; // 色相が回転
        }
      }

      function handleSuperFire(dt) {
        if (!state.superModeActive) return;
        const interval = Math.max(0.06, superSettings.autoFireInterval);
        if (state.superShotsRemaining <= 0) {
          endSuperMode();
          return;
        }
        state.superFireTimer = (state.superFireTimer || 0) + dt;
        while (state.superFireTimer >= interval) {
          state.superFireTimer -= interval;
          if (state.superShotsRemaining <= 0) {
            endSuperMode();
            break;
          }
          const shotBatch = Math.min(superSettings.autoLockMax, state.superShotsRemaining);
          const targets = selectNearestAnchors(shotBatch).slice(0, shotBatch);
          if (!targets.length) break;
          fireHomingVolley(targets);
          state.superShotsRemaining = Math.max(0, state.superShotsRemaining - targets.length);
          if (state.superShotsRemaining <= 0) {
            endSuperMode();
            break;
          }
        }
      }

      function updateHomingLaser(laser, dt) {
        if (laser.delay > 0) {
          laser.delay -= dt;
          return;
        }
        laser.life -= dt;
        if (laser.life <= 0) {
          laser.done = true;
          return;
        }
        let target = getEnemyById(laser.targetId);
        if (!target) {
          laser.done = true;
          return;
        }
        const turnRate = (laser.turnRate || 6) * dt;
        const aim = getAnchorPosition(target, laser.anchorKey || "core") || target;
        const dx = aim.x - laser.x;
        const dy = aim.y - laser.y;
        const dz = aim.z - laser.z;
        const dist = Math.hypot(dx, dy, dz) || 0.0001;
        const desiredVx = (dx / dist) * (laser.speed || 150);
        const desiredVy = (dy / dist) * (laser.speed || 150);
        const desiredVz = (dz / dist) * (laser.speed || 150);
        laser.vx = (laser.vx ?? 0) + (desiredVx - (laser.vx ?? 0)) * Math.min(1, turnRate);
        laser.vy = (laser.vy ?? 0) + (desiredVy - (laser.vy ?? 0)) * Math.min(1, turnRate);
        laser.vz = (laser.vz ?? 0) + (desiredVz - (laser.vz ?? 0)) * Math.min(1, turnRate);
        laser.x += (laser.vx ?? 0) * dt;
        laser.y += (laser.vy ?? 0) * dt;
        laser.z += (laser.vz ?? 0) * dt;
        laser.trailTimer = (laser.trailTimer || 0) + dt;
        if (laser.trailTimer > 0.05) {
          spawnHomingTrail(laser);
          laser.trailTimer = 0;
        }
        laser.tailRecordTimer = (laser.tailRecordTimer || 0) + dt;
        if (laser.tailRecordTimer > 0.025) {
          laser.ribbon = laser.ribbon || [];
          laser.ribbon.unshift({ x: laser.x, y: laser.y, z: laser.z });
          if (laser.ribbon.length > 32) {
            laser.ribbon.pop();
          }
          laser.tailRecordTimer = 0;
        }
      }

      function spawnHomingTrail(laser) {
        // 誘導レーザーの残光を淡い青で描画
        state.explosions.push({
          x: laser.x,
          y: laser.y,
          z: laser.z,
          vx: (laser.vx ?? 0) * -0.02,
          vy: (laser.vy ?? 0) * -0.02,
          vz: (laser.vz ?? 0) * -0.02,
          life: 0.25,
          color: state.superModeActive ? "#ffd966" : "#7ff",
          width: 2,
          glow: state.superModeActive ? "#ffd966" : "#7ff",
          glowBlur: 12
        });
      }

      function toggleDebugMode() {
        state.debugMode = !state.debugMode;
        if (state.debugMode) {
          state.shield = settings.maxShield;
        }
      }

      function spawnExplosion(x, y, z, color, count) {
        // ワイヤーフレーム風の飛散粒子を生成（スローで余韻を強調）
        for (let i = 0; i < count; i++) {
          const speed = 18 + Math.random() * 28;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const vx = Math.cos(theta) * Math.sin(phi) * speed;
          const vy = Math.sin(theta) * Math.sin(phi) * speed;
          const vz = Math.cos(phi) * speed * 0.7;
          state.explosions.push({
            x,
            y,
            z,
            vx,
            vy,
            vz,
            life: 0.9 + Math.random() * 0.7,
            color
          });
        }
      }

      function spawnLingeringExplosion(x, y, z, color) {
        const count = 30;
        for (let i = 0; i < count; i++) {
          const speed = 6 + Math.random() * 4;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const vx = Math.cos(theta) * Math.sin(phi) * speed * 0.2;
          const vy = Math.sin(theta) * Math.sin(phi) * speed * 0.2;
          const vz = Math.cos(phi) * speed * 0.3;
          state.explosions.push({
            x,
            y,
            z,
            vx,
            vy,
            vz,
            life: 1.2 + Math.random() * 0.6,
            color
          });
        }
      }

      function spawnShardBurst(x, y, z, color = "#fff") {
        // 小型敵爆発に鋭い破片を足してスピード感を演出
        const count = 22;
        for (let i = 0; i < count; i++) {
          const speed = 28 + Math.random() * 36;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          state.explosions.push({
            x,
            y,
            z,
            vx: Math.cos(theta) * Math.sin(phi) * speed,
            vy: Math.sin(theta) * Math.sin(phi) * speed,
            vz: Math.cos(phi) * speed * 0.6,
            life: 0.8 + Math.random() * 0.4,
            color,
            width: 2.2 + Math.random() * 1.4,
            glow: color,
            glowBlur: 8
          });
        }
      }

      function spawnShockwaveRing(x, y, z, color = "#fff") {
        // 衝撃波リングで爆心地の強さを可視化
        state.shockwaves.push({
          x,
          y,
          z,
          radius: 3,
          expansion: 42,
          life: 0.9,
          initialLife: 0.9,
          color,
          width: 4.5
        });
      }

      function spawnRadiantBloom(x, y, z, { color = "#fff", layers = 3, radius = 48 } = {}) {
        // 大型艦専用の巨大な発光を段階的に描き、特別感を演出
        for (let i = 0; i < layers; i++) {
          const t = i / Math.max(1, layers - 1);
          spawnShockwaveRing(x, y, z + i * 2, color);
          state.explosions.push({
            x,
            y,
            z: z + i * 1.5,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            vz: (Math.random() - 0.5) * 1.2,
            life: 2.2 + t * 1.4,
            color,
            width: radius * (1 - t * 0.6),
            glow: color,
            glowBlur: radius * (1.2 - t * 0.8)
          });
        }
      }

      function spawnEnhancedEnemyExplosion(x, y, z, color = "#fff") {
        // 敵機撃破時は閃光→破片→残光の三段構えで派手さを底上げ
        playExplosionSound(0.85);
        const accent = color === "#0f9" ? "#8ff" : "#0ff";
        spawnShockwaveRing(x, y, z, "#fff");
        spawnExplosion(x, y, z, color, 24);
        spawnExplosion(x, y, z, "#fff", 12);
        spawnShardBurst(x, y, z, accent);
        spawnLingeringExplosion(x, y, z + 4, accent);
      }

      function spawnShieldSpark(x, y, z, color = "#0ff") {
        for (let i = 0; i < 14; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 20 + Math.random() * 40;
          state.explosions.push({
            x,
            y,
            z,
            vx: Math.cos(angle) * speed * 0.04,
            vy: Math.sin(angle) * speed * 0.04,
            vz: (Math.random() - 0.5) * speed * 0.08,
            life: 0.2 + Math.random() * 0.25,
            color
          });
        }
      }

      function scheduleSegmentChain(enemy, segmentKey, delay = 0.25) {
        // 旗艦の誘爆イベントを一定時間後に実行
        state.chainReactions.push({ enemy, segmentKey, timer: delay });
      }

      function triggerNeighborChain(enemy, segment) {
        // 隣接セグメントを数個だけランダムに誘爆させる
        if (!segment?.neighbors || !enemy?.segmentMap) return;
        const candidates = segment.neighbors
          .map(key => enemy.segmentMap[key])
          .filter(seg => seg && !seg.destroyed && !isSegmentLocked(enemy, seg));
        if (candidates.length === 0) return;
        const chainCount = Math.min(candidates.length, 1 + Math.floor(Math.random() * 2));
        for (let i = 0; i < chainCount; i++) {
          const index = Math.floor(Math.random() * candidates.length);
          const target = candidates.splice(index, 1)[0];
          scheduleSegmentChain(enemy, target.key, 0.25 + Math.random() * 0.25);
        }
      }

      function queueDelayedExplosion(enemy, { delay = 0.6, color = "#fff", score = 0, mega = false, megaHandler = null } = {}) {
        if (enemy.pendingExplosion) return;
        enemy.dead = true;
        enemy.pendingExplosion = true;
        enemy.explosionDelay = delay + explosionSettings.extraDelay;
        enemy.pendingExplosionColor = color;
        enemy.pendingExplosionScore = score;
        enemy.pendingMegaExplosion = Boolean(mega);
        enemy.megaExplosionHandler = megaHandler;
        enemy.flash = 0.6;
        enemy.scoreAwarded = false;
      }

      function queueBattleshipExplosion(enemy) {
        queueDelayedExplosion(enemy, { delay: 0.75, color: "#fff", score: 200, mega: true });
        initHullBreakSequence(enemy, { duration: enemy.explosionDelay || 1.2, baseColor: "#0ff" });
        registerPlayerKill(enemy, 6);
      }

      function queueDreadnoughtExplosion(enemy) {
        queueDelayedExplosion(enemy, { delay: 1.3, color: "#fff", score: 1200, mega: true, megaHandler: spawnDreadnoughtCataclysm });
        initHullBreakSequence(enemy, { duration: enemy.explosionDelay || 1.6, baseColor: "#fff", accentColor: "#f88" });
        showMessage("FLAGSHIP NEUTRALIZED", 4.2);
        registerPlayerKill(enemy, 10);
      }

      function initHullBreakSequence(enemy, { duration = 1.4, baseColor = "#fff", accentColor = "#0ff" } = {}) {
        // 大型艦の最終爆発前に船体各所から火花を散らすスケジュールを作成
        if (!enemy) return;
        const anchors = [];
        if (enemy.segments && enemy.segments.length > 0) {
          enemy.segments.forEach((segment, idx) => {
            const pos = segmentWorldPosition(enemy, segment);
            anchors.push({ ...pos, weight: segment.final ? 2 : 1 + (idx % 2) });
          });
        } else {
          const fallback = Math.max(4, Math.min(8, enemy.size ? Math.floor(enemy.size / 3) : 5));
          for (let i = 0; i < fallback; i++) {
            anchors.push({
              x: enemy.x + (Math.random() - 0.5) * 20,
              y: enemy.y + (Math.random() - 0.5) * 12,
              z: enemy.z + (Math.random() - 0.5) * 20,
              weight: 1
            });
          }
        }
        const stageCount = Math.max(4, Math.min(anchors.length, 9));
        const timeline = [];
        for (let i = 0; i < stageCount; i++) {
          const anchor = anchors[i % anchors.length];
          const offset = (i / stageCount) * duration * 0.85 + Math.random() * 0.1;
          const color = i % 2 === 0 ? baseColor : accentColor;
          timeline.push({
            time: Math.min(duration * 0.95, offset),
            color,
            radius: 14 + (anchor.weight || 1) * 2,
            pos: {
              x: anchor.x + (Math.random() - 0.5) * 2,
              y: anchor.y + (Math.random() - 0.5) * 2,
              z: anchor.z + (Math.random() - 0.5) * 2
            }
          });
        }
        timeline.sort((a, b) => a.time - b.time);
        enemy.hullBreakTimeline = timeline;
        enemy.hullBreakElapsed = 0;
      }

      function updateHullBreakSequence(enemy, dt) {
        // タイムラインに従って小爆発を発生させる
        if (!enemy?.hullBreakTimeline || enemy.hullBreakTimeline.length === 0) return;
        enemy.hullBreakElapsed = (enemy.hullBreakElapsed || 0) + dt;
        while (enemy.hullBreakTimeline.length && enemy.hullBreakElapsed >= enemy.hullBreakTimeline[0].time) {
          const burst = enemy.hullBreakTimeline.shift();
          const color = burst.color || "#fff";
          const pos = burst.pos || enemy;
          spawnExplosion(pos.x, pos.y, pos.z, color, burst.radius || 12);
          if (Math.random() < 0.6) {
            spawnShardBurst(pos.x, pos.y, pos.z, color);
          }
          if (Math.random() < 0.35) {
            spawnShockwaveRing(pos.x, pos.y, pos.z, color);
          }
        }
      }

      function applyBattleshipSegmentDamage(enemy, segment, segPos) {
        if (segment.destroyed) return;
        segment.hp = Math.max(0, (segment.hp ?? 1) - 1);
        enemy.cumulativeDamage += 40;
        enemy.flash = 0.2;
        state.score += 120;
        spawnExplosion(segPos.x, segPos.y, segPos.z, "#0ff", segment.hp > 0 ? 10 : 20);
        if (segment.hp <= 0) {
          segment.destroyed = true;
        }
        const lockRemaining = enemy.segments.some(seg => seg.lockable && !seg.destroyed);
        if (!lockRemaining && !enemy.pendingExplosion) {
          enemy.dead = true;
          queueBattleshipExplosion(enemy);
          return;
        }
        if (lockRemaining) return; // 弱点が残っている間は艦体を沈められない
        if (enemy.cumulativeDamage >= enemy.damageThreshold && !enemy.pendingExplosion) {
          enemy.dead = true;
          queueBattleshipExplosion(enemy);
        }
      }

      function applyDreadnoughtSegmentDamage(enemy, segment, segPos) {
        if (segment.destroyed) return;
        if (isSegmentLocked(enemy, segment)) {
          spawnShieldSpark(segPos.x, segPos.y, segPos.z, "#0ff");
          enemy.flash = 0.12;
          return;
        }
        const maxScore = segment.score ?? 400;
        const partialScore = Math.max(80, Math.floor(maxScore * 0.25));
        const wasFinalHit = (segment.hp ?? 1) <= 1;
        segment.hp = Math.max(0, (segment.hp ?? 1) - 1);
        enemy.flash = 0.25;
        const color = segment.generator ? "#0ff" : segment.final ? "#fff" : "#0ff";
        spawnExplosion(segPos.x, segPos.y, segPos.z, color, wasFinalHit ? 28 : 16);
        if (segment.hp <= 0) {
          segment.destroyed = true;
          state.score += maxScore;
          spawnLingeringExplosion(segPos.x, segPos.y, segPos.z, color);
          if (segment.generator) {
            showMessage("SHIELD GENERATOR DOWN", 3.2);
          }
          if (segment.final) {
            queueDreadnoughtExplosion(enemy);
          } else {
            const core = enemy.segmentMap?.core;
            if (core && !core.destroyed && !isSegmentLocked(enemy, core) && !enemy.coreAnnounced) {
              enemy.coreAnnounced = true;
              showMessage("CORE EXPOSED - FINISH IT", 3.8);
              // コア露出は「勝ち筋が見えた瞬間」なので、ここでライバル乱入を発火させる
              triggerRivalArrival(enemy);
            }
            triggerNeighborChain(enemy, segment);
          }
        } else {
          state.score += partialScore;
        }
      }

      function spawnBattleshipMegaExplosion(enemy) {
        // 爆発の粒子を多めに、ゆっくり広がるように
        playExplosionSound(1.1);
        const colorCycle = ["#fff", "#0ff", "#f88"];
        const center = { x: enemy.x, y: enemy.y, z: enemy.z };
        const slow = 0.22;
        for (let i = 0; i < 55; i++) {
          const speed = 12 + Math.random() * 20;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;
          const vx = Math.cos(theta) * Math.sin(phi) * speed * slow;
          const vy = Math.sin(theta) * Math.sin(phi) * speed * slow;
          const vz = Math.cos(phi) * speed * 0.4 * slow;
          state.explosions.push({
            x: center.x,
            y: center.y,
            z: center.z,
            vx,
            vy,
            vz,
            life: 2.4 + Math.random() * 1.1,
            color: colorCycle[i % colorCycle.length]
          });
        }
        spawnRadiantBloom(center.x, center.y, center.z, { color: "#6ef", layers: 4, radius: 56 });
        spawnExplosion(center.x, center.y, center.z, "#fff", 20);
      }

      function spawnDreadnoughtCataclysm(enemy) {
        playExplosionSound(1.4);
        const center = { x: enemy.x, y: enemy.y, z: enemy.z };
        const ringColors = ["#fff", "#0ff", "#f88"];
        const slow = 0.18;
        for (let ring = 0; ring < 3; ring++) {
          const count = 28 + ring * 18;
          const radius = 10 + ring * 9;
          const color = ringColors[ring % ringColors.length];
          for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count;
            const speed = 28 + ring * 12 + Math.random() * 10;
            state.explosions.push({
              x: center.x + Math.cos(angle) * radius * 0.25,
              y: center.y + Math.sin(angle) * radius * 0.25,
              z: center.z + ring * 4,
              vx: Math.cos(angle) * speed * slow,
              vy: Math.sin(angle) * speed * slow,
              vz: (Math.random() - 0.5) * speed * 0.6 * slow,
              life: 2.6 + Math.random() * 1.5,
              color
            });
          }
        }
        spawnRadiantBloom(center.x, center.y, center.z + 4, { color: "#ffd966", layers: 5, radius: 68 });
        spawnExplosion(center.x, center.y, center.z, "#fff", 40);
        spawnLingeringExplosion(center.x, center.y, center.z + 6, "#0ff");
      }

      // 敵が自機の前方にいて死角でないかを確認
      function canEnemyShoot(enemy) {
        return withinForwardConePosition(enemy);
      }

      function isEnemyVisible(enemy) {
        return isPositionVisible(enemy);
      }

      function withinForwardConePosition(position) {
        if (!position) return false;
        const profile = getEnemyFireProfile();
        if (position.z < profile.behindThreshold) return false;
        if (Math.abs(position.x) > profile.blindCone) return false;
        if (Math.abs(position.y) > profile.verticalCone) return false;
        return true;
      }

      function isPositionVisible(position) {
        const minDepth = lockSettings.minDepth || 2;
        if (!position || position.z <= minDepth) return false;
        const proj = project(position);
        return proj.x > -40 && proj.x < canvas.width + 40 && proj.y > -40 && proj.y < canvas.height + 40;
      }

      // 後方からは発射せず、規定時間ごとにレーザーを射出
      function attemptEnemyFire(enemy, dt) {
        if (enemy.retired || enemy.pendingExplosion) return;
        if (enemy.type === "rival") {
          attemptRivalFire(enemy, dt);
          return;
        }
        if (enemy.type === "dreadnought") {
          attemptDreadnoughtFire(enemy, dt);
          return;
        }
        const profile = getEnemyFireProfile();
        const intensity = profile.intensity || 0;
        enemy.fireTimer += dt;
        const baseDelay = enemy.fireDelay || profile.minDelay;
        const effectiveDelay = Math.max(0.85, baseDelay * (1.15 - intensity * 0.4));
        if (enemy.fireTimer < effectiveDelay) return;
        enemy.fireTimer = 0;
        if (!canEnemyShoot(enemy)) return;
        if (!isEnemyVisible(enemy)) return;
        if (Math.random() > profile.fireChance) return;
        const dir = aimAtPlayer(enemy);
        spawnEnemyRocket({ x: enemy.x, y: enemy.y, z: enemy.z - 6 }, dir, {
          speed: profile.rocketSpeed + Math.random() * 2.4,
          accel: profile.rocketAccel,
          color: "#f64"
        });
      }

      function attemptRivalFire(enemy, dt) {
        // ライバル機は命中圧を上げるため、低確率バーストで撃ってくる
        enemy.fireTimer += dt;
        const delay = enemy.fireDelay || 1.0;
        if (enemy.fireTimer < delay) return;
        enemy.fireTimer = 0;
        if (!canEnemyShoot(enemy)) return;
        if (!isEnemyVisible(enemy)) return;
        if (Math.random() > 0.75) return;
        const base = aimAtPlayer(enemy);
        const spread = [-0.08, 0, 0.08];
        for (let i = 0; i < spread.length; i++) {
          const dir = {
            x: base.x + spread[i],
            y: base.y + (i === 1 ? 0 : -0.02),
            z: base.z
          };
          const mag = Math.hypot(dir.x, dir.y, dir.z) || 0.0001;
          dir.x /= mag; dir.y /= mag; dir.z /= mag;
          spawnEnemyRocket({ x: enemy.x, y: enemy.y, z: enemy.z - 8 }, dir, {
            speed: 10 + Math.random() * 4,
            accel: 24,
            maxSpeed: 40,
            color: "#ff4d4d",
            glow: "#ffd1d1"
          });
        }
      }

      function tryRivalEmergencyEvade(enemy, laser) {
        // 被弾直前の緊急回避。ロックオンゲーなので「回避して粘る」をここで実現する。
        if (!enemy || enemy.type !== "rival") return false;
        if (enemy.pendingExplosion || enemy.retired) return false;
        if ((enemy.phaseShift || 0) > 0) return true; // 既に位相ズレ中なら当たりを無効化
        if ((enemy.evadeCooldown || 0) > 0) return false;
        const energy = enemy.evadeEnergy ?? 0;
        const cost = enemy.evadeCost ?? 30;
        if (energy < cost) return false;

        // 誘導レーザーは避けにくいが、ゼロではない（クライマックス用に薄く残す）
        const baseChance = laser?.type === "homing" ? 0.35 : 0.72;
        if (Math.random() > baseChance) return false;

        enemy.evadeEnergy = Math.max(0, energy - cost);
        enemy.evadeCooldown = 0.55;
        enemy.phaseShift = 0.18;
        enemy.flash = 0.55;

        // 横っ飛び + 奥へ一気に下がって、同じレーンで削られ続けないようにする
        const dir = (Math.random() < 0.5 ? -1 : 1);
        const jukeX = dir * (18 + Math.random() * 22);
        const jukeY = -dir * (8 + Math.random() * 14);
        enemy.x += jukeX;
        enemy.y += jukeY;
        enemy.z = Math.min(380, (enemy.z ?? 180) + (18 + Math.random() * 26));
        enemy.vx += dir * (10 + Math.random() * 8);
        enemy.vy += -dir * (7 + Math.random() * 6);

        spawnShockwaveRing(enemy.x, enemy.y, enemy.z, "#ff4d4d");
        spawnExplosion(enemy.x, enemy.y, enemy.z, "#ffd1d1", 10);
        return true;
      }

      function aimAtPlayer(enemy) {
        return aimFromPoint(enemy);
      }

      function aimFromPoint(point) {
        const dx = -point.x;
        const dy = -point.y;
        const dz = -point.z;
        const mag = Math.hypot(dx, dy, dz) || 0.0001;
        return { x: dx / mag, y: dy / mag, z: dz / mag };
      }

      function attemptDreadnoughtFire(enemy, dt) {
        enemy.turretTimers = enemy.turretTimers || {};
        for (const segment of enemy.segments) {
          if (!segment.turret || segment.destroyed) continue;
          if (isSegmentLocked(enemy, segment)) continue;
          const segPos = segmentWorldPosition(enemy, segment);
          if (!withinForwardConePosition(segPos)) continue;
          if (!isPositionVisible(segPos)) continue;
          enemy.turretTimers[segment.key] = (enemy.turretTimers[segment.key] || 0) + dt;
          const delay = segment.fireDelay || enemy.fireDelay || 3.2;
          if (enemy.turretTimers[segment.key] < delay) continue;
          enemy.turretTimers[segment.key] = Math.random() * 0.8;
          if (Math.random() > 0.85) continue;
          const dir = aimFromPoint(segPos);
          spawnEnemyRocket({ x: segPos.x, y: segPos.y, z: segPos.z - 6 }, dir, {
            speed: 6 + Math.random() * 2,
            accel: 20,
            maxSpeed: 34,
            color: "#f88",
            glow: "#fdd"
          });
        }
      }
      function resetBattleshipSegments(enemy) {
        if (!enemy.segments) return;
        enemy.segments.forEach(seg => seg.destroyed = false);
      }

      function segmentWorldPosition(enemy, segment) {
        return {
          x: enemy.x + (segment.offsetX || 0),
          y: enemy.y + (segment.offsetY || 0),
          z: enemy.z + (segment.offsetZ || 0)
        };
      }

      function isSegmentLocked(enemy, segment) {
        if (!segment?.requires || !enemy?.segmentMap) return false;
        return segment.requires.some(key => {
          const req = enemy.segmentMap[key];
          return req && !req.destroyed;
        });
      }

      // ワープ演出中の速度・姿勢・演出強度を管理
      function handleWarpPhase(dt) {
        if (state.warpPhase === "combat") {
          state.warpIntensity += (0 - state.warpIntensity) * dt * 2.4;
          state.warpFlashIntensity = Math.max(0, (state.warpFlashIntensity || 0) - dt * 1.6);
          return;
        }
        state.warpTimer += dt;
        state.warpRingTimer = (state.warpRingTimer || 0) + dt;
        state.warpFlashIntensity = Math.max(0, (state.warpFlashIntensity || 0) - dt * 0.9);
        const entryEnd = 3.2;
        const flareStart = 6.0;
        const burnEnd = 7.4;
        const ringInterval = Math.max(0.12, 0.26 - Math.min(0.14, state.warpIntensity * 0.06));
        if (state.warpRingTimer >= ringInterval) {
          state.warpRingTimer = 0;
          const z = 70 + Math.random() * 70;
          const color = state.warpTimer > flareStart ? "#f9f" : "#8ff";
          spawnShockwaveRing((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 4, z, color);
          state.warpFlashIntensity = Math.min(1, (state.warpFlashIntensity || 0) + 0.16);
        }
        if (state.warpTimer < entryEnd) {
          state.speed += (settings.maxSpeed * 0.9 - state.speed) * dt * 1.3;
          state.warpIntensity += (1.8 - state.warpIntensity) * dt * 2.2;
          state.yaw *= 0.99; // 自動安定
          state.pitch *= 0.99;
        } else if (state.warpTimer < flareStart) {
          state.speed += (settings.maxSpeed * 1.15 - state.speed) * dt * 1.35;
          state.warpIntensity += (2.4 - state.warpIntensity) * dt * 2.1;
          if (!state.warpAnnounceDone) {
            pushComms("管制: ワープ航路焼き付き、姿勢固定");
            state.warpAnnounceDone = true;
          }
        } else if (state.warpTimer < burnEnd) {
          state.speed += (settings.maxSpeed * 1.32 - state.speed) * dt * 1.45;
          state.warpIntensity += (2.9 - state.warpIntensity) * dt * 2.1;
          state.warpFlashIntensity = Math.min(1, (state.warpFlashIntensity || 0) + dt * 0.9);
          if (Math.random() < 0.25) {
            spawnExplosion((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 7, 85 + Math.random() * 60, "#bff", 6);
          }
        } else {
          state.warpPhase = "combat";
          state.warpIntensity = 0.8;
          state.warpFlashIntensity = 0.55;
          state.speed = Math.min(state.speed, settings.maxSpeed);
          pushComms("宙域突破、交戦開始");
          showMessage("OBERON SECTOR - STAGE START", 2.8);
        }
      }

      // ワープ中は入力を軽く減衰させて直進させる
      function dampenDuringWarp(dt) {
        state.roll *= Math.exp(-dt * 4);
        state.yaw *= Math.exp(-dt * 3);
        state.pitch *= Math.exp(-dt * 3);
      }

      // 無線チャッターをランダムに発生させてスペースオペラ感を演出
      function handleChatter(dt) {
        state.chatterTimer += dt;
        if (state.chatterTimer < state.nextChatter) return;
        state.chatterTimer = 0;
        state.nextChatter = 5 + Math.random() * 5;
        const lines = [
          "僚機: 視界奥に航宙戦艦、砲塔多いぞ",
          "管制: 旗艦のコアが露出寸前、仕留めろ",
          "僚機: 艦載機が上がった、編隊を崩す",
          "管制: OBERON回廊、弾薬節約を推奨",
          "僚機: ワイヤーフレームでもデカいな…"
        ];
        const pick = lines[Math.floor(Math.random() * lines.length)];
        pushComms(pick);
      }

      function update(dt) {
        if (!state.running) return;
        const playerDt = dt;
        const worldScale = state.superModeActive ? superSettings.worldTimeScale : 1;
        const worldDt = playerDt * worldScale;
        if (state.messageTimer > 0) {
          state.messageTimer -= playerDt;
          if (state.messageTimer <= 0) {
            message.textContent = "";
          }
        }
        state.timeSinceStart += worldDt;
        handleWarpPhase(worldDt);
        updateFormationAnchors(worldDt);
        handleSpawnTimer();
        if (state.warpPhase === "combat") handleInput(playerDt);
        else dampenDuringWarp(worldDt);
        dt = worldDt;
        // 星を移動させて疑似的な速度感を演出
        for (const star of state.stars) {
          star.z -= dt * state.speed * 0.6;
          if (star.z < 5) star.z += 200;
        }
        handleChatter(dt);
        updateLockOn(dt);
        updatePowerState(playerDt);
        updateSuperModeEffects(playerDt); // 派手エフェクト更新
        updateHomingHeat(playerDt);
        handleSuperFire(playerDt);

        // プレイヤー姿勢で敵配置もゆっくり揺らし、追われる感覚を簡易再現
        for (const enemy of state.enemies) {
          enemy.age = (enemy.age || 0) + dt;

          const isCarrierInterceptor = enemy.type === "fighter" && enemy.carrierTag;
          const retreatSpeed = enemy.retreatSpeed ?? settings.enemyRetreatBase;
          const maxApproach = enemy.maxApproachRate ?? settings.maxApproachRate;
          const recedeFactor = enemy.recedeFactor ?? settings.enemyRecedeFactor;
          if (!enemy.pendingExplosion) {
            if (isCarrierInterceptor) {
              const orbitPhase = enemy.orbitAngle || 0;
              const desiredZ = 68 + Math.sin(orbitPhase * 1.25) * 12;
              enemy.z += (desiredZ - enemy.z) * dt * 4.8;
            } else {
              const relativeForward = state.speed - retreatSpeed;
              if (relativeForward > 0) {
                const approach = Math.min(relativeForward, maxApproach);
                enemy.z -= approach * dt;
              } else if (relativeForward < 0) {
                const recede = Math.min(retreatSpeed, -relativeForward) * recedeFactor;
                enemy.z += recede * dt;
              }
            }
          }

          const formation = enemy.formationGroup ? state.formations[enemy.formationGroup] : null;
          let formationTarget = null;
          if (formation && !enemy.pendingExplosion) {
            formationTarget = {
              x: formation.anchorX + (enemy.formationOffset?.x || 0),
              y: formation.anchorY + (enemy.formationOffset?.y || 0)
            };
          }
          if (formationTarget && !enemy.pendingExplosion && !isCarrierInterceptor && enemy.type !== "fighter") {
            const dx = formationTarget.x - enemy.x;
            const dy = formationTarget.y - enemy.y;
            enemy.vx = dx * 3;
            enemy.vy = dy * 3;
          }
          enemy.x += dt * enemy.vx + state.yaw * dt * 0.4;
          enemy.y += dt * enemy.vy - state.pitch * dt * 0.4;
          if (enemy.z > 420 && !enemy.dead) {
            enemy.dead = true;
            enemy.retired = true;
            releaseFormationSlot(enemy);
            continue;
          }
          if (isCarrierInterceptor) {
            updateCarrierInterceptor(enemy, dt);
          } else if (enemy.type === "fighter") {
            updateFormationFighterFlight(enemy, dt, formationTarget);
          } else if (enemy.type === "rival") {
            // ライバルは蛇行しつつ急接近→急後退で撃ち合いを作る
            const swayX = Math.sin(enemy.age * 2.2 + enemy.phase) * 18;
            const swayY = Math.cos(enemy.age * 1.8 + enemy.phase) * 10;
            enemy.vx = (swayX - enemy.x) * 0.9;
            enemy.vy = (swayY - enemy.y) * 0.9;
            // 見た目の「ロール」を付けてロボット兵器っぽく見せる
            enemy.flightRoll = Math.sin(enemy.age * 3.1 + enemy.phase) * 55;
            // 回避リソース管理（回避し続けて理不尽にならないようにする）
            const emax = enemy.evadeEnergyMax ?? 100;
            const regen = enemy.evadeRegen ?? 20;
            enemy.evadeEnergy = Math.min(emax, (enemy.evadeEnergy ?? emax) + regen * dt);
            enemy.evadeCooldown = Math.max(0, (enemy.evadeCooldown || 0) - dt);
            enemy.phaseShift = Math.max(0, (enemy.phaseShift || 0) - dt);
          } else if (enemy.type === "corvette") {
            enemy.x += Math.sin(enemy.age * 1.8 + enemy.phase) * 6 * dt;
            enemy.y += Math.cos(enemy.age * 1.2 + enemy.phase) * 3 * dt;
          } else if (enemy.type === "dreadnought") {
            const sway = enemy.pendingExplosion ? 0 : 1;
            enemy.x += Math.sin(enemy.age * 0.35 + enemy.driftPhase) * dt * 8 * sway;
            enemy.y += Math.cos(enemy.age * 0.28 + enemy.driftPhase) * dt * 4 * sway;
            handleCarrierLaunch(enemy, dt);
          }
          if (enemy.pendingExplosion) {
            // 爆発までの遅延演出を進める
            enemy.explosionDelay -= dt;
            enemy.flash = Math.max(0, enemy.flash - dt);
            updateHullBreakSequence(enemy, dt);
            if (enemy.explosionDelay <= 0) {
              if (enemy.pendingMegaExplosion) {
                if (enemy.megaExplosionHandler) {
                  enemy.megaExplosionHandler(enemy);
                } else {
                  spawnBattleshipMegaExplosion(enemy);
                }
              } else {
                spawnEnhancedEnemyExplosion(enemy.x, enemy.y, enemy.z, enemy.pendingExplosionColor || "#fff");
              }
              if (!enemy.scoreAwarded && enemy.pendingExplosionScore) {
                state.score += enemy.pendingExplosionScore;
                enemy.scoreAwarded = true;
              }
              enemy.retired = true;
              enemy.megaExplosionHandler = null;
              enemy.hullBreakTimeline = null;
              releaseFormationSlot(enemy);
            }
            continue;
          }
          attemptEnemyFire(enemy, dt);
          if (enemy.z < 5 && !enemy.dead) {
            const damage = enemy.type === "dreadnought" ? 40 : enemy.type === "battleship" ? 25 : enemy.type === "corvette" ? 12 : 6;
            if (!state.debugMode) {
              state.shield -= damage;
            }
            gainPowerFromHit(damage);
            enemy.dead = true;
            if (enemy.type === "dreadnought") {
              enemy.retired = true;
              releaseFormationSlot(enemy);
              spawnDreadnoughtCataclysm(enemy);
            } else {
              const color = enemy.type === "battleship" ? "#fff" : "#f44";
              queueDelayedExplosion(enemy, { delay: 0.35, color });
            }
          }
          if (enemy.flash > 0) enemy.flash -= dt;
        }

        // レーザー移動とヒット判定
        for (const laser of state.lasers) {
          if (laser.type === "homing") {
            updateHomingLaser(laser, dt);
          } else {
            laser.z += laser.vz * dt;
          }
        }
        state.lasers = state.lasers.filter(l => {
          if (l.done) return false;
          if (l.type === "homing") {
            return l.life > 0 && l.z > -20 && l.z < 420;
          }
          return l.z < 400;
        });
        // 敵レーザーを移動させて自機に触れるか判定
        for (const shot of state.enemyShots) {
          if (shot.type === "rocket") {
            shot.vx += shot.ax * dt;
            shot.vy += shot.ay * dt;
            shot.vz += shot.az * dt;
            const speed = Math.hypot(shot.vx, shot.vy, shot.vz);
            const cap = shot.maxSpeed || 36;
            if (speed > cap && speed > 0) {
              const scale = cap / speed;
              shot.vx *= scale;
              shot.vy *= scale;
              shot.vz *= scale;
            }
            shot.trailTimer = (shot.trailTimer || 0) + dt;
            if (shot.trailTimer > 0.045) {
              spawnRocketTrail(shot);
              shot.trailTimer = 0;
            }
          }
          shot.x += shot.vx * dt;
          shot.y += shot.vy * dt;
          shot.z += shot.vz * dt;
          if (shot.z < 5 && !shot.done) {
            shot.done = true;
            state.shield -= 8;
            gainPowerFromHit(8);
            spawnExplosion(shot.x, shot.y, shot.z, "#f44", 10);
            playExplosionSound(0.4);
          }
        }
        state.enemyShots = state.enemyShots.filter(shot => shot.z > -20 && !shot.done);
        // 爆発パーティクル更新
        for (const particle of state.explosions) {
          particle.life -= dt;
          particle.x += particle.vx * dt;
          particle.y += particle.vy * dt;
          particle.z += particle.vz * dt;
        }
        state.explosions = state.explosions.filter(p => p.life > 0);

        // 誘爆イベントを遅延実行
        const nextChains = [];
        for (const chain of state.chainReactions) {
          const remaining = chain.timer - dt;
          if (remaining <= 0) {
            const enemy = chain.enemy;
            const segment = enemy?.segmentMap?.[chain.segmentKey];
            if (enemy && !enemy.retired && segment && !segment.destroyed) {
              const segPos = segmentWorldPosition(enemy, segment);
              spawnExplosion(segPos.x, segPos.y, segPos.z, "#fdd", 14);
              applyDreadnoughtSegmentDamage(enemy, segment, segPos);
            }
          } else {
            nextChains.push({ ...chain, timer: remaining });
          }
        }
        state.chainReactions = nextChains;

        // 衝撃波の寿命と拡散を管理
        for (const wave of state.shockwaves) {
          wave.life -= dt;
          wave.radius += wave.expansion * dt;
          wave.width = Math.max(0.8, wave.width - dt * 4.5);
        }
        state.shockwaves = state.shockwaves.filter(wave => wave.life > 0);

        // 3D距離しきい値で命中判定（簡易スフィア）
        for (const enemy of state.enemies) {
          for (const laser of state.lasers) {
            if (laser.done) continue;
            if (enemy.type === "dreadnought") {
              for (const segment of enemy.segments) {
                if (segment.destroyed) continue;
                if (segment.lockable) {
                  if (laser.type !== "homing") continue;
                  const requiredKey = getSegmentLockKey(segment);
                  if (laser.anchorKey && laser.anchorKey !== requiredKey) continue;
                }
                const segPos = segmentWorldPosition(enemy, segment);
                const dx = segPos.x - laser.x;
                const dy = segPos.y - laser.y;
                const dz = segPos.z - laser.z;
                if (Math.abs(dz) < 18 && Math.hypot(dx, dy) < (segment.size + 3)) {
                  applyDreadnoughtSegmentDamage(enemy, segment, segPos);
                  laser.done = true;
                  break;
                }
              }
            } else if (enemy.type === "battleship") {
              for (const segment of enemy.segments) {
                if (segment.destroyed) continue;
                if (segment.lockable) {
                  if (laser.type !== "homing") continue;
                  const requiredKey = getSegmentLockKey(segment);
                  if (laser.anchorKey && laser.anchorKey !== requiredKey) continue;
                }
                const segPos = segmentWorldPosition(enemy, segment);
                const dx = segPos.x - laser.x;
                const dy = segPos.y - laser.y;
                const dz = segPos.z - laser.z;
                if (Math.abs(dz) < 16 && Math.hypot(dx, dy) < (segment.size + 2)) {
                  applyBattleshipSegmentDamage(enemy, segment, segPos);
                  laser.done = true;
                  break;
                }
              }
            } else if (enemy.type === "corvette") {
              const dx = enemy.x - laser.x;
              const dy = enemy.y - laser.y;
              const dz = enemy.z - laser.z;
              if (Math.abs(dz) < 14 && Math.hypot(dx, dy) < 10) {
                enemy.flash = 0.2;
                enemy.dead = true;
                queueDelayedExplosion(enemy, { delay: 0.4, color: "#0f9", score: 150 });
                registerPlayerKill(enemy);
                laser.done = true;
              }
            } else {
              const dx = enemy.x - laser.x;
              const dy = enemy.y - laser.y;
              const dz = enemy.z - laser.z;
              const zTol = enemy.type === "rival" ? 14 : 12;
              const rTol = enemy.type === "rival" ? 10 : 6;
              if (Math.abs(dz) < zTol && Math.hypot(dx, dy) < rTol) {
                // ライバルは「被弾寸前の回避」で粘り、クライマックスの一騎打ちを成立させる
                if (enemy.type === "rival") {
                  const evaded = tryRivalEmergencyEvade(enemy, laser);
                  if (evaded) {
                    laser.done = true;
                    continue;
                  }
                }
                // 小型機は即撃破、ライバル機のみ多段ヒット（盛り上げ優先）
                if (enemy.type === "rival" && (enemy.hp ?? 1) > 1) {
                  enemy.hp = Math.max(0, (enemy.hp ?? 1) - 1);
                  enemy.flash = 0.35;
                  state.score += 80;
                  spawnExplosion(enemy.x, enemy.y, enemy.z, "#ffd1d1", 16);
                  spawnShockwaveRing(enemy.x, enemy.y, enemy.z, "#ff4d4d");
                  if (enemy.hp === 3) {
                    showMessage("RIVAL ARMOR BREAK", 2.2);
                    pushComms("???: いい機体だ…だが、まだだ！");
                  }
                } else {
                  enemy.flash = 0.2;
                  enemy.dead = true;
                  if (enemy.type === "rival") {
                    queueDelayedExplosion(enemy, { delay: 0.9, color: "#ff4d4d", score: 650 });
                    registerPlayerKill(enemy, 12);
                    state.rivalDefeated = true;
                    pushComms("???: ……次は負けない");
                    showMessage("RIVAL DOWN", 2.6);
                  } else {
                    queueDelayedExplosion(enemy, { delay: 0.35, color: "#f0f", score: 100 });
                    registerPlayerKill(enemy);
                  }
                }
                laser.done = true;
              }
            }
          }
        }

        state.enemies = state.enemies.filter(enemy => !enemy.retired);
        if (state.enemies.length === 0 && state.zoneSpawnIndex >= stageZones.length) {
          loopStage();
          return;
        }

        if (state.shield <= 0 && !state.debugMode) {
          state.running = false;
          message.textContent = "MISSION FAILED - PRESS R";
        }

      }

      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "#0ff";
        ctx.lineWidth = 1;

        // 星のスキャンライン（ワープ強度で伸ばす）
        ctx.beginPath();
        ctx.strokeStyle = state.warpPhase === "combat" ? "#0ff" : "#9ef";
        for (const star of state.stars) {
          const head = project(star);
          const tailOffset = 4 + state.warpIntensity * 18;
          const tail = project({ x: star.x, y: star.y, z: star.z + tailOffset });
          ctx.moveTo(tail.x, tail.y);
          ctx.lineTo(head.x, head.y);
        }
        ctx.stroke();

        // ワープトンネルの追加演出（序盤の派手さを強調）
        if (state.warpPhase !== "combat") {
          const cx = canvas.width / 2;
          const cy = canvas.height / 2;
          const intensity = clamp01((state.warpIntensity || 0) / 2.9);
          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          ctx.globalAlpha = 0.65;
          const rays = 56;
          const inner = 18 + intensity * 34;
          const outer = Math.max(canvas.width, canvas.height) * (0.35 + intensity * 0.45);
          for (let i = 0; i < rays; i++) {
            const phase = (state.warpTimer || 0) * 0.65;
            const angle = (Math.PI * 2 * i) / rays + phase;
            const wobble = Math.sin(phase * 1.6 + i) * (2 + intensity * 5);
            const aX = cx + Math.cos(angle) * inner;
            const aY = cy + Math.sin(angle) * inner;
            const bX = cx + Math.cos(angle) * (outer + wobble);
            const bY = cy + Math.sin(angle) * (outer + wobble);
            const col = i % 2 === 0 ? "#8ff" : "#f8f";
            ctx.strokeStyle = col;
            ctx.lineWidth = 1.2 + intensity * 1.4;
            ctx.beginPath();
            ctx.moveTo(aX, aY);
            ctx.lineTo(bX, bY);
            ctx.stroke();
          }
          const flash = clamp01((state.warpFlashIntensity || 0) * 0.4 + intensity * 0.08);
          if (flash > 0) {
            ctx.globalCompositeOperation = "source-over";
            ctx.fillStyle = `rgba(160, 240, 255, ${flash})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
          ctx.restore();
        }

        // レーザーを細線で表示
        for (const laser of state.lasers) {
          drawPlayerLaser(laser);
        }
        // 敵ロケットの描画（視認性を高める）
        for (const shot of state.enemyShots) {
          if (shot.type === "rocket") {
            drawEnemyRocket(shot);
          } else {
            const p = project(shot);
            ctx.strokeStyle = "#f44";
            ctx.beginPath();
            ctx.moveTo(p.x - 1, p.y);
            ctx.lineTo(p.x + 1, p.y);
            ctx.stroke();
          }
        }

        // 敵ワイヤーフレーム（小型/大型）を描画
        for (const enemy of state.enemies) {
          if (enemy.type === "dreadnought") {
            drawDreadnought(enemy);
          } else if (enemy.type === "battleship") {
            drawBattleship(enemy);
          } else if (enemy.type === "corvette") {
            drawCorvette(enemy);
          } else if (enemy.type === "rival") {
            drawRivalWeapon(enemy);
          } else {
            drawFighter(enemy);
          }
        }

        // 爆発パーティクルをベクタースタイルで描画
        for (const particle of state.explosions) {
          const tail = {
            x: particle.x - particle.vx * 0.015,
            y: particle.y - particle.vy * 0.015,
            z: particle.z - particle.vz * 0.015
          };
          const a = project(tail);
          const b = project(particle);
          ctx.save();
          ctx.strokeStyle = particle.color || "#fff";
          ctx.lineWidth = particle.width || 1;
          if (particle.glow) {
            ctx.shadowColor = particle.glow;
            ctx.shadowBlur = particle.glowBlur || 6;
          }
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
          ctx.restore();
        }

        for (const wave of state.shockwaves) {
          drawShockwave(wave);
        }

        // コクピット枠
        ctx.strokeStyle = "#0ff";
        ctx.beginPath();
        ctx.moveTo(0, canvas.height * 0.7);
        ctx.lineTo(canvas.width * 0.3, canvas.height);
        ctx.lineTo(canvas.width * 0.7, canvas.height);
        ctx.lineTo(canvas.width, canvas.height * 0.7);
        ctx.stroke();

        drawRotatedCrosshair();
        drawLockInterface();

        const hudLines = [];
        const shieldText = state.debugMode ? "∞" : Math.max(state.shield, 0);
        let baseLine = `SPEED ${state.speed.toFixed(0)}   SHIELD ${shieldText}   SCORE ${state.score}`;
        if (state.debugMode) baseLine += "   DEBUG MODE";
        hudLines.push(baseLine);
        const lockLine = `LOCK ${state.lockedTargets.length}/${lockSettings.maxTargets}`;
        const powerPercent = getPowerPercent();
        const powerLine = state.superModeActive
          ? `POWER 100% / SUPER ${state.superModeTimer.toFixed(1)}s`
          : state.superReady
            ? "POWER 100% / SUPER READY (X)"
            : powerPercent >= 100
              ? `POWER 100% (NEED COMBO x${powerSettings.superComboMin})   COMBO x${Math.max(1, state.comboCount || 1)}`
              : `POWER ${powerPercent}%   COMBO x${Math.max(1, state.comboCount || 1)}`;
        const homingStatus = state.superModeActive
          ? "H-LASER INFINITE"
          : state.homingOverheat > 0
            ? `H-LASER COOL ${state.homingOverheat.toFixed(1)}s`
            : `H-LASER READY ${Math.max(0, homingWeaponSettings.maxChain - state.homingChainCount)}/${homingWeaponSettings.maxChain}`;
        hudLines.push(`${lockLine}   ${powerLine}`);
        hudLines.push(homingStatus);
        const flagship = state.enemies.find(e => e.type === "dreadnought" && !e.retired);
        if (flagship) {
          const total = flagship.segments.length;
          const destroyed = flagship.segments.filter(seg => seg.destroyed).length;
          const locked = flagship.segments.filter(seg => !seg.destroyed && isSegmentLocked(flagship, seg)).length;
          const status = flagship.pendingExplosion
            ? "SCUTTLE"
            : locked > 0
              ? `LOCK ${locked}`
              : "CORE OPEN";
          hudLines.push(`FLAGSHIP ${destroyed}/${total}   ${status}`);
        }
        const rival = state.enemies.find(e => e.type === "rival" && !e.retired && !e.pendingExplosion);
        if (rival) {
          hudLines.push(`RIVAL HP ${Math.max(0, rival.hp ?? 0)}/${Math.max(1, rival.maxHp ?? 1)}`);
        }
        hudLines.push(state.sectorLabel);
        comms.textContent = state.navLog.slice(-5).join("\n");
        hud.textContent = hudLines.join("\n");
        updateAIPanelGuideVisibility();

        // ★ スーパーモード派手エフェクト描画 ★
        // サイキックウェーブ（画面中心から広がる波紋）
        for (const wave of state.superPsychicWaves) {
          if (wave.alpha <= 0) continue;
          ctx.save();
          ctx.beginPath();
          ctx.arc(canvas.width / 2, canvas.height / 2, wave.radius, 0, Math.PI * 2);
          ctx.strokeStyle = `hsla(${wave.hue}, 100%, 70%, ${wave.alpha})`;
          ctx.lineWidth = 4 + (1 - wave.alpha) * 8;
          ctx.shadowColor = `hsla(${wave.hue}, 100%, 80%, 0.8)`;
          ctx.shadowBlur = 20;
          ctx.stroke();
          ctx.restore();
        }

        // オーラパーティクル（放射状に飛び散る光の粒子）
        for (const p of state.newtypeAuraParticles) {
          if (p.life <= 0) continue;
          ctx.save();
          const alpha = Math.min(1, p.life);
          ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${alpha})`;
          ctx.shadowColor = `hsla(${p.hue}, 100%, 80%, ${alpha})`;
          ctx.shadowBlur = 12;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // スーパーモード時の画面フラッシュ
        if (state.superFlashIntensity > 0) {
          ctx.save();
          ctx.fillStyle = `rgba(255, 220, 100, ${state.superFlashIntensity * 0.6})`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }

        // スーパーモード中の色相シフトオーバーレイ（サイケデリック効果）
        if (state.superModeActive) {
          ctx.save();
          const hue = state.superHueShift % 360;
          ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.06)`;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          // 画面端に金色のグロー
          const gradient = ctx.createRadialGradient(
            canvas.width / 2, canvas.height / 2, canvas.height * 0.3,
            canvas.width / 2, canvas.height / 2, canvas.height * 0.8
          );
          gradient.addColorStop(0, "rgba(255, 215, 0, 0)");
          gradient.addColorStop(0.7, "rgba(255, 180, 50, 0.08)");
          gradient.addColorStop(1, "rgba(255, 100, 0, 0.15)");
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }

      }

      function drawFighter(enemy) {
        const color = enemy.flash > 0 ? "#fff" : "#f0f";
        withDepthRendering(enemy, color, () => {
          const rollDeg = enemy.carrierRoll ?? enemy.flightRoll ?? 0;
          const rollRad = rollDeg * (Math.PI / 180);
          const cosR = Math.cos(rollRad);
          const sinR = Math.sin(rollRad);
          const rollPoint = (lx, ly, lz) => ({
            x: enemy.x + lx * cosR - ly * sinR,
            y: enemy.y + lx * sinR + ly * cosR,
            z: enemy.z + lz
          });
          const points = [
            rollPoint(-6, 0, 8),
            rollPoint(6, 0, 8),
            rollPoint(0, 0, -10)
          ].map(p => project(p));
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          ctx.lineTo(points[1].x, points[1].y);
          ctx.lineTo(points[2].x, points[2].y);
          ctx.closePath();
          ctx.stroke();
          ctx.beginPath();
          const leftTail = project(rollPoint(-4, -2, -4));
          ctx.moveTo(points[0].x, points[0].y);
          ctx.lineTo(leftTail.x, leftTail.y);
          ctx.stroke();
          ctx.beginPath();
          const rightTail = project(rollPoint(4, -2, -4));
          ctx.moveTo(points[1].x, points[1].y);
          ctx.lineTo(rightTail.x, rightTail.y);
          ctx.stroke();
          ctx.lineWidth = 1;
          drawWireCube({ x: enemy.x, y: enemy.y, z: enemy.z }, 5, color);
        });
      }

      function drawRivalWeapon(enemy) {
        // ライバル機は「人型ロボット兵器」にして、艦艇/戦闘機とシルエットで差別化する
        const baseColor = enemy.flash > 0 ? "#fff" : "#ff4d4d";
        withDepthRendering(enemy, baseColor, () => {
          const rollDeg = enemy.flightRoll ?? 0;
          const rollRad = rollDeg * (Math.PI / 180);
          const cosR = Math.cos(rollRad);
          const sinR = Math.sin(rollRad);
          const rollPoint = (lx, ly, lz) => ({
            x: enemy.x + lx * cosR - ly * sinR,
            y: enemy.y + lx * sinR + ly * cosR,
            z: enemy.z + lz
          });

          // === 人型スケルトン（超簡易ワイヤーフレーム） ===
          const headW = rollPoint(0, -10, -6);
          const neckW = rollPoint(0, -6, -2);
          const chestW = rollPoint(0, -2, 2);
          const pelvisW = rollPoint(0, 4, 6);
          const shoulderLW = rollPoint(-9, -4, 0);
          const shoulderRW = rollPoint(9, -4, 0);
          const elbowLW = rollPoint(-14, 0, 4);
          const elbowRW = rollPoint(14, 0, 4);
          const handLW = rollPoint(-11, 4, 10);
          const handRW = rollPoint(11, 4, 10);
          const hipLW = rollPoint(-6, 6, 8);
          const hipRW = rollPoint(6, 6, 8);
          const kneeLW = rollPoint(-7, 12, 8);
          const kneeRW = rollPoint(7, 12, 8);
          const footLW = rollPoint(-7, 18, 10);
          const footRW = rollPoint(7, 18, 10);
          const packW = rollPoint(0, 0, 14);

          const head = project(headW);
          const neck = project(neckW);
          const chest = project(chestW);
          const pelvis = project(pelvisW);
          const shoulderL = project(shoulderLW);
          const shoulderR = project(shoulderRW);
          const elbowL = project(elbowLW);
          const elbowR = project(elbowRW);
          const handL = project(handLW);
          const handR = project(handRW);
          const hipL = project(hipLW);
          const hipR = project(hipRW);
          const kneeL = project(kneeLW);
          const kneeR = project(kneeRW);
          const footL = project(footLW);
          const footR = project(footRW);
          const pack = project(packW);
          ctx.save();
          ctx.strokeStyle = baseColor;
          ctx.shadowColor = "#ffd1d1";
          ctx.shadowBlur = 14;
          ctx.lineWidth = 1.6;

          // 胴体
          ctx.beginPath();
          ctx.moveTo(head.x, head.y);
          ctx.lineTo(neck.x, neck.y);
          ctx.lineTo(chest.x, chest.y);
          ctx.lineTo(pelvis.x, pelvis.y);
          ctx.stroke();

          // 腕
          ctx.beginPath();
          ctx.moveTo(shoulderL.x, shoulderL.y);
          ctx.lineTo(elbowL.x, elbowL.y);
          ctx.lineTo(handL.x, handL.y);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(shoulderR.x, shoulderR.y);
          ctx.lineTo(elbowR.x, elbowR.y);
          ctx.lineTo(handR.x, handR.y);
          ctx.stroke();

          // 肩～胸ライン
          ctx.beginPath();
          ctx.moveTo(shoulderL.x, shoulderL.y);
          ctx.lineTo(chest.x, chest.y);
          ctx.lineTo(shoulderR.x, shoulderR.y);
          ctx.stroke();

          // 脚
          ctx.beginPath();
          ctx.moveTo(hipL.x, hipL.y);
          ctx.lineTo(kneeL.x, kneeL.y);
          ctx.lineTo(footL.x, footL.y);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(hipR.x, hipR.y);
          ctx.lineTo(kneeR.x, kneeR.y);
          ctx.lineTo(footR.x, footR.y);
          ctx.stroke();

          // 腰ライン
          ctx.beginPath();
          ctx.moveTo(hipL.x, hipL.y);
          ctx.lineTo(pelvis.x, pelvis.y);
          ctx.lineTo(hipR.x, hipR.y);
          ctx.stroke();

          // バックパック（推進器）
          ctx.beginPath();
          ctx.moveTo(chest.x, chest.y);
          ctx.lineTo(pack.x, pack.y);
          ctx.stroke();

          ctx.shadowBlur = 0;
          // ロボっぽい塊感をキューブで少し足す（読みやすさ優先）
          drawWireCube({ x: enemy.x, y: enemy.y - 2, z: enemy.z + 4 }, 7, baseColor); // 胴体
          drawWireCube({ x: enemy.x, y: enemy.y - 10, z: enemy.z - 6 }, 4.2, baseColor); // 頭
          // HPリング（HUD以外でも削り具合が分かるようにする）
          const hp = Math.max(0, enemy.hp ?? 0);
          const max = Math.max(1, enemy.maxHp ?? 1);
          const pct = hp / max;
          const center = project(enemy);
          // 位相ズレ中はリングを青白くして「避けた」感を出す
          const shifting = (enemy.phaseShift || 0) > 0;
          ctx.strokeStyle = shifting ? "rgba(180,220,255,0.9)" : "rgba(255,255,255,0.7)";
          ctx.lineWidth = 2.2;
          ctx.beginPath();
          ctx.arc(center.x, center.y, 18, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * pct);
          ctx.stroke();
          // 回避エネルギー（薄い外周リング）: 長期戦の「今いける/避ける」を視覚化
          const e = Math.max(0, enemy.evadeEnergy ?? 0);
          const emax = Math.max(1, enemy.evadeEnergyMax ?? 1);
          const epct = e / emax;
          ctx.strokeStyle = "rgba(255, 200, 200, 0.55)";
          ctx.lineWidth = 1.4;
          ctx.beginPath();
          ctx.arc(center.x, center.y, 23, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * epct);
          ctx.stroke();
          ctx.restore();
        });
      }

      function drawEnemyRocket(shot) {
        const head = project(shot);
        const tailVec = {
          x: shot.x - shot.vx * 0.12,
          y: shot.y - shot.vy * 0.12,
          z: shot.z - shot.vz * 0.12
        };
        const tail = project(tailVec);
        const sideVec = {
          x: shot.x + (shot.vy * 0.04),
          y: shot.y - (shot.vx * 0.04),
          z: shot.z
        };
        const side = project(sideVec);
        ctx.save();
        ctx.strokeStyle = shot.color || "#f64";
        ctx.fillStyle = shot.color || "#f64";
        ctx.lineWidth = 3.5;
        ctx.shadowColor = shot.glow || "#ff8";
        ctx.shadowBlur = 18;
        ctx.beginPath();
        ctx.moveTo(head.x, head.y);
        ctx.lineTo(tail.x, tail.y);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.moveTo(head.x, head.y);
        ctx.lineTo(tail.x, tail.y);
        ctx.lineTo(side.x, side.y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawPlayerLaser(laser) {
        if (laser.type === "homing") {
          drawHomingBeam(laser);
          return;
        }
        const front = project(laser);
        const tail = project({ x: laser.x, y: laser.y, z: laser.z - 16 });
        ctx.save();
        ctx.strokeStyle = "#6ef";
        ctx.lineWidth = 4;
        ctx.shadowColor = "#6ef";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(tail.x, tail.y);
        ctx.lineTo(front.x, front.y);
        ctx.stroke();
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = "#0ff";
        ctx.beginPath();
        ctx.moveTo(tail.x, tail.y);
        ctx.lineTo(front.x, front.y);
        ctx.stroke();
        ctx.fillStyle = "#9ff";
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(front.x, front.y, 3.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function drawHomingBeam(laser) {
        const tailFactor = 0.3;
        const front = project(laser);
        const back = project({
          x: laser.x - (laser.vx ?? 0) * tailFactor,
          y: laser.y - (laser.vy ?? 0) * tailFactor,
          z: laser.z - (laser.vz ?? 0) * tailFactor
        });
        ctx.save();
        const color = state.superModeActive ? "#ffd966" : "#7ff";
        ctx.strokeStyle = color;
        ctx.lineWidth = 5;
        ctx.shadowColor = color;
        ctx.shadowBlur = 16;
        ctx.beginPath();
        ctx.moveTo(back.x, back.y);
        ctx.lineTo(front.x, front.y);
        ctx.stroke();
        ctx.lineWidth = 2;
        ctx.shadowBlur = 0;
        ctx.strokeStyle = "#fff";
        ctx.beginPath();
        ctx.moveTo(back.x, back.y);
        ctx.lineTo(front.x, front.y);
        ctx.stroke();
        if (laser.ribbon && laser.ribbon.length > 1) {
          // リボンを滑らかなフェードで描画し、誘導レーザーらしい尾を演出
          const projectedRibbon = laser.ribbon.map(node => project(node));
          ctx.save();
          for (let i = 0; i < projectedRibbon.length - 1; i++) {
            const a = projectedRibbon[i];
            const b = projectedRibbon[i + 1];
            const t = i / (projectedRibbon.length - 1);
            const width = 4 - t * 3;
            const alpha = 0.5 * (1 - t);
            ctx.strokeStyle = color;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = Math.max(1, width);
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }
          ctx.restore();
        }
        ctx.restore();
      }

      function drawShockwave(wave) {
        // 爆心地を囲むリングをスクリーン空間に投影して描画
        const alpha = Math.max(0, wave.life / wave.initialLife);
        const segments = 20;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = wave.color;
        ctx.lineWidth = wave.width;
        ctx.beginPath();
        for (let i = 0; i <= segments; i++) {
          const angle = (Math.PI * 2 * i) / segments;
          const point = project({
            x: wave.x + Math.cos(angle) * wave.radius,
            y: wave.y + Math.sin(angle) * wave.radius,
            z: wave.z
          });
          if (i === 0) ctx.moveTo(point.x, point.y);
          else ctx.lineTo(point.x, point.y);
        }
        ctx.stroke();
        ctx.restore();
      }

      function drawCorvette(enemy) {
        const color = enemy.flash > 0 ? "#fff" : "#0f9";
        withDepthRendering(enemy, color, () => {
          const hull = [];
          const length = 16;
          const width = 8;
          const height = 3;
          for (let i = 0; i < 6; i++) {
            const k = i / 5;
            hull.push({
              x: enemy.x + Math.sin(k * Math.PI) * width * 0.6,
              y: enemy.y + (i % 2 === 0 ? -height : height),
              z: enemy.z - length * (k - 0.5)
            });
          }
          ctx.beginPath();
          hull.forEach((p, idx) => {
            const proj = project(p);
            if (idx === 0) ctx.moveTo(proj.x, proj.y);
            else ctx.lineTo(proj.x, proj.y);
          });
          ctx.closePath();
          ctx.stroke();
          const bridge = project({ x: enemy.x, y: enemy.y - 2, z: enemy.z - 4 });
          const stern = project({ x: enemy.x, y: enemy.y, z: enemy.z + 6 });
          ctx.beginPath();
          ctx.moveTo(bridge.x, bridge.y);
          ctx.lineTo(stern.x, stern.y);
          ctx.stroke();
          drawWireCube({ x: enemy.x, y: enemy.y, z: enemy.z + 4 }, 4, color);
        });
      }

      function drawBattleship(enemy) {
        const color = enemy.flash > 0 ? "#fff" : "#0ff";
        withDepthRendering(enemy, color, () => {
          const hullLength = 20;
          const nose = project({ x: enemy.x, y: enemy.y, z: enemy.z - hullLength });
          const tail = project({ x: enemy.x, y: enemy.y, z: enemy.z + hullLength * 0.3 });
          ctx.beginPath();
          ctx.moveTo(nose.x, nose.y);
          ctx.lineTo(tail.x, tail.y);
          ctx.stroke();
          const wingLeft = project({ x: enemy.x - 12, y: enemy.y, z: enemy.z - 6 });
          const wingRight = project({ x: enemy.x + 12, y: enemy.y, z: enemy.z - 6 });
          ctx.beginPath();
          ctx.moveTo(wingLeft.x, wingLeft.y);
          ctx.lineTo(wingRight.x, wingRight.y);
          ctx.stroke();
          const deck = project({ x: enemy.x, y: enemy.y - 3, z: enemy.z });
          ctx.beginPath();
          ctx.arc(deck.x, deck.y, 6, 0, Math.PI * 2);
          ctx.stroke();
          const centers = [];
          for (const segment of enemy.segments) {
            if (segment.destroyed) continue;
            const pos = segmentWorldPosition(enemy, segment);
            centers.push(pos);
            drawGuideFrame(pos, segment.size || 9, color);
          }
          for (let i = 0; i < centers.length - 1; i++) {
            const a = project(centers[i]);
            const b = project(centers[i + 1]);
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }
        });
      }

      function drawDreadnought(enemy) {
        const color = enemy.flash > 0 ? "#fff" : "#0ff";
        withDepthRendering(enemy, color, () => {
          const prow = project({ x: enemy.x, y: enemy.y - 6, z: enemy.z - 34 });
          const stern = project({ x: enemy.x, y: enemy.y + 4, z: enemy.z + 22 });
          ctx.beginPath();
          ctx.moveTo(prow.x, prow.y);
          ctx.lineTo(stern.x, stern.y);
          ctx.stroke();
          const hullLeft = project({ x: enemy.x - 24, y: enemy.y + 6, z: enemy.z - 6 });
          const hullRight = project({ x: enemy.x + 24, y: enemy.y + 6, z: enemy.z - 6 });
          ctx.beginPath();
          ctx.moveTo(hullLeft.x, hullLeft.y);
          ctx.lineTo(prow.x, prow.y);
          ctx.lineTo(hullRight.x, hullRight.y);
          ctx.stroke();
          const keelLeft = project({ x: enemy.x - 18, y: enemy.y + 2, z: enemy.z + 12 });
          const keelRight = project({ x: enemy.x + 18, y: enemy.y + 2, z: enemy.z + 12 });
          ctx.beginPath();
          ctx.moveTo(keelLeft.x, keelLeft.y);
          ctx.lineTo(stern.x, stern.y);
          ctx.lineTo(keelRight.x, keelRight.y);
          ctx.stroke();
          const intactSegments = [];
          for (const segment of enemy.segments) {
            if (segment.destroyed) continue;
            const segPos = segmentWorldPosition(enemy, segment);
            const locked = isSegmentLocked(enemy, segment);
            const segColor = locked ? "#066" : color;
            drawGuideFrame(segPos, segment.size || 12, segColor);
            if (segment.final && !locked) {
              const center = project(segPos);
              const cross = (segment.size || 10) * 0.6;
              ctx.beginPath();
              ctx.moveTo(center.x - cross, center.y);
              ctx.lineTo(center.x + cross, center.y);
              ctx.moveTo(center.x, center.y - cross);
              ctx.lineTo(center.x, center.y + cross);
              ctx.stroke();
            }
            intactSegments.push({ pos: segPos, locked });
          }
          for (let i = 0; i < intactSegments.length - 1; i++) {
            const a = project(intactSegments[i].pos);
            const b = project(intactSegments[i + 1].pos);
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }
        });
      }

      function drawGuideFrame(center, size, color) {
        drawWireCube(center, size, color);
        ctx.strokeStyle = color;
        ctx.beginPath();
        const left = project({ x: center.x - size * 0.6, y: center.y, z: center.z });
        const right = project({ x: center.x + size * 0.6, y: center.y, z: center.z });
        ctx.moveTo(left.x, left.y);
        ctx.lineTo(right.x, right.y);
        ctx.stroke();
        ctx.beginPath();
        const top = project({ x: center.x, y: center.y - size * 0.5, z: center.z });
        const bottom = project({ x: center.x, y: center.y + size * 0.5, z: center.z });
        ctx.moveTo(top.x, top.y);
        ctx.lineTo(bottom.x, bottom.y);
        ctx.stroke();
      }

      function drawWireCube(center, size, color) {
        const s = size;
        const verts = [
          [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s],
          [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]
        ].map(v => ({ x: center.x + v[0], y: center.y + v[1], z: center.z + v[2] }));
        drawWireShape(verts, [
          [0, 1], [1, 2], [2, 3], [3, 0],
          [4, 5], [5, 6], [6, 7], [7, 4],
          [0, 4], [1, 5], [2, 6], [3, 7]
        ], color);
      }

      function drawWireShape(verts, edges, color) {
        ctx.strokeStyle = color;
        ctx.beginPath();
        edges.forEach(([a, b]) => {
          const pa = project(verts[a]);
          const pb = project(verts[b]);
          ctx.moveTo(pa.x, pa.y);
          ctx.lineTo(pb.x, pb.y);
        });
        ctx.stroke();
      }

      function project(point) {
        // 3D座標→2D投影: x/z・y/z比に視野角を掛けてスクリーン中央に足す
        const scale = settings.fov / (point.z || 0.0001);
        return {
          x: canvas.width / 2 + point.x * scale,
          y: canvas.height / 2 + point.y * scale
        };
      }

      function depthEffect(enemy) {
        const depth = Math.min(420, Math.max(enemy.z, 20));
        const normalized = (depth - 20) / 400;
        const factor = 1 - normalized;
        const alpha = Math.min(1, Math.max(0.25, 0.35 + factor * 0.65));
        const width = 0.5 + factor * 1.8;
        return { alpha, width };
      }

      function withDepthRendering(enemy, color, drawFn) {
        const effect = depthEffect(enemy);
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = effect.width;
        ctx.globalAlpha = effect.alpha;
        drawFn();
        ctx.restore();
      }

      function drawRotatedCrosshair() {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const angle = -state.roll * settings.rollVisualFactor * Math.PI / 180;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);
        ctx.strokeStyle = "#0ff";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-20, 0);
        ctx.lineTo(-5, 0);
        ctx.moveTo(20, 0);
        ctx.lineTo(5, 0);
        ctx.moveTo(0, -20);
        ctx.lineTo(0, -5);
        ctx.moveTo(0, 20);
        ctx.lineTo(0, 5);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(0, 0, 12, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      function drawLockInterface() {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const color = state.superModeActive ? "#ffd966" : "#5ef";
        ctx.save();
        ctx.strokeStyle = color;
        ctx.globalAlpha = 0.65;
        ctx.setLineDash([6, 6]);
        ctx.lineDashOffset = -state.lockPulse * 35;
        ctx.beginPath();
        ctx.arc(cx, cy, lockSettings.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        const lockingAnchor = state.lockingAnchor;
        if (lockingAnchor && lockingAnchor.progress > 0) {
          const ratio = Math.min(1, lockingAnchor.progress / (lockingAnchor.max || 1));
          const anchorPos = lockingAnchor.screen || { x: cx, y: cy };
          ctx.save();
          ctx.strokeStyle = color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(anchorPos.x, anchorPos.y, 18, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * ratio);
          ctx.stroke();
          ctx.restore();
        }
        state.lockedTargets.forEach((lock, idx) => {
          const enemy = lock.enemy || getEnemyById(lock.enemyId);
          if (!enemy) return;
          const anchorPos = getAnchorPosition(enemy, lock.anchorKey || "core");
          if (!anchorPos) return;
          const proj = project(anchorPos);
          ctx.save();
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.rect(proj.x - 12, proj.y - 12, 24, 24);
          ctx.stroke();
          ctx.fillStyle = color;
          ctx.font = "12px 'Courier New', monospace";
          ctx.fillText(`${idx + 1}`, proj.x + 14, proj.y - 12);
          ctx.restore();
        });
      }

      function loop(timestamp) {
        if (!state.lastTime) state.lastTime = timestamp;
        const dt = Math.min(0.033, (timestamp - state.lastTime) / 1000);
        state.lastTime = timestamp;
        update(dt);
        render();
        requestAnimationFrame(loop);
      }

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      init();
    })();
  </script>
</body>

</html>
